{"ast":null,"code":"import { Subject, Subscription, BehaviorSubject, combineLatest, timer, EMPTY, of } from 'rxjs';\nimport { filter, debounce, switchMap, tap, delay, finalize, takeUntil, map } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, EventEmitter, Component, ChangeDetectionStrategy, Input, Output, NgModule } from '@angular/core';\nimport * as i2 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n\nfunction NgProgressComponent_ng_container_0_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 6);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"box-shadow\", \"0 0 10px \" + ctx_r2.color + \", 0 0 5px \" + ctx_r2.color);\n  }\n}\n\nfunction NgProgressComponent_ng_container_0_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 7);\n    i0.ɵɵelement(1, \"div\", 8);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"border-top-color\", ctx_r3.color)(\"border-left-color\", ctx_r3.color);\n  }\n}\n\nfunction NgProgressComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 1)(2, \"div\", 2)(3, \"div\", 3);\n    i0.ɵɵtemplate(4, NgProgressComponent_ng_container_0_div_4_Template, 1, 2, \"div\", 4);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵtemplate(5, NgProgressComponent_ng_container_0_div_5_Template, 2, 4, \"div\", 5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const state_r1 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"transition\", \"opacity \" + ctx_r0.speed + \"ms \" + ctx_r0.ease);\n    i0.ɵɵattribute(\"active\", state_r1.active);\n    i0.ɵɵadvance(2);\n    i0.ɵɵstyleProp(\"transform\", state_r1.transform)(\"background-color\", ctx_r0.color)(\"transition\", state_r1.active ? \"all \" + ctx_r0.speed + \"ms \" + ctx_r0.ease : \"none\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.meteor);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.spinner);\n  }\n}\n\nclass NgProgressRef {\n  constructor(customConfig, _onDestroyCallback) {\n    this._onDestroyCallback = _onDestroyCallback; // Progress start source event (used to cancel finalizing delays)\n\n    this._started = new Subject(); // Progress start event: stream that emits only when it hasn't already started\n\n    this.started = this._started.pipe(filter(() => !this.isStarted)); // Progress ended source event\n\n    this._completed = new Subject(); // Progress start event: stream that emits only when it has already started\n\n    this.completed = this._completed.pipe(filter(() => this.isStarted)); // Stream that increments and updates the progress state\n\n    this._trickling = new Subject(); // Stream that combines \"_trickling\" and \"config\" streams\n\n    this._worker = Subscription.EMPTY;\n    this._state = new BehaviorSubject({\n      active: false,\n      value: 0\n    });\n    this._config = new BehaviorSubject(customConfig);\n    this.state = this._state.asObservable();\n    this.config = this._config.asObservable();\n    this._worker = combineLatest([this._trickling, this._config]).pipe(debounce(([start, config]) => timer(start ? config.debounceTime : 0)), switchMap(([start, config]) => start ? this.onTrickling(config) : this.onComplete(config))).subscribe();\n  } // Get current progress state\n\n\n  get snapshot() {\n    return this._state.value;\n  } // Check if progress has started\n\n\n  get isStarted() {\n    return this.snapshot.active;\n  }\n  /**\n   * Start the progress\n   */\n\n\n  start() {\n    this._started.next();\n\n    this._trickling.next(true);\n  }\n  /**\n   * Complete the progress\n   */\n\n\n  complete() {\n    this._trickling.next(false);\n  }\n  /**\n   * Increment the progress\n   */\n\n\n  inc(amount) {\n    const n = this.snapshot.value;\n\n    if (!this.isStarted) {\n      this.start();\n    } else {\n      if (typeof amount !== 'number') {\n        amount = this._config.value.trickleFunc(n);\n      }\n\n      this.set(n + amount);\n    }\n  }\n  /**\n   * Set the progress\n   */\n\n\n  set(n) {\n    this.setState({\n      value: this.clamp(n),\n      active: true\n    });\n  }\n  /**\n   * Set config\n   */\n\n\n  setConfig(config) {\n    this._config.next(Object.assign(Object.assign({}, this._config.value), config));\n  }\n  /**\n   * Destroy progress reference\n   */\n\n\n  destroy() {\n    this._worker.unsubscribe();\n\n    this._trickling.complete();\n\n    this._state.complete();\n\n    this._config.complete();\n\n    this._started.complete();\n\n    this._completed.complete();\n\n    this._onDestroyCallback();\n  }\n  /**\n   * Set progress state\n   */\n\n\n  setState(state) {\n    this._state.next(Object.assign(Object.assign({}, this.snapshot), state));\n  }\n  /**\n   * Clamps a value to be between min and max\n   */\n\n\n  clamp(n) {\n    return Math.max(this._config.value.min, Math.min(this._config.value.max, n));\n  }\n  /**\n   * Keeps incrementing the progress\n   */\n\n\n  onTrickling(config) {\n    if (!this.isStarted) {\n      this.set(this._config.value.min);\n    }\n\n    return timer(0, config.trickleSpeed).pipe(tap(() => this.inc()));\n  }\n  /**\n   * Completes then resets the progress\n   */\n\n\n  onComplete(config) {\n    this._completed.next();\n\n    return !this.isStarted ? EMPTY : of({}).pipe( // Complete the progress\n    tap(() => this.setState({\n      value: 100\n    })), // Deactivate the progress after a tiny delay\n    delay(config.speed * 1.7), tap(() => this.setState({\n      active: false\n    })), // Use a tiny delay before resetting\n    delay(config.speed), // Force the progress to reset even it got cancelled\n    finalize(() => this.setState({\n      value: 0\n    })), // Cancel any of the finalizing delays if the progress has started again\n    takeUntil(this._started));\n  }\n\n}\n\nconst NG_PROGRESS_CONFIG = new InjectionToken('ngProgressConfig');\nconst defaultConfig = {\n  min: 8,\n  max: 100,\n  speed: 200,\n  debounceTime: 0,\n  trickleSpeed: 300,\n  fixed: true,\n  meteor: true,\n  thick: false,\n  spinner: true,\n  ease: 'linear',\n  color: '#1B95E0',\n  direction: 'ltr+',\n  spinnerPosition: 'right',\n  trickleFunc: n => {\n    if (n >= 0 && n < 20) return 10;\n    if (n >= 20 && n < 50) return 4;\n    if (n >= 50 && n < 80) return 2;\n    if (n >= 80 && n < 99) return 0.5;\n    return 0;\n  }\n};\nlet NgProgress = /*#__PURE__*/(() => {\n  class NgProgress {\n    constructor(config) {\n      // Store progress bar instances\n      this._instances = new Map();\n      this.config = config ? Object.assign(Object.assign({}, defaultConfig), config) : defaultConfig;\n    }\n    /**\n     * Get or Create progress bar by ID\n     */\n\n\n    ref(id = 'root', config) {\n      if (this._instances.has(id)) {\n        // Get ProgressRef instance\n        const progressRef = this._instances.get(id);\n\n        if (config) {\n          progressRef.setConfig(Object.assign(Object.assign({}, this.config), config));\n        }\n\n        return progressRef;\n      } else {\n        // Create new ProgressRef instance\n        const progressRef = new NgProgressRef(Object.assign(Object.assign({}, this.config), config), this.deleteInstance(id));\n        return this._instances.set(id, progressRef).get(id);\n      }\n    }\n    /**\n     * Destroy all progress bar instances\n     */\n\n\n    destroyAll() {\n      this._instances.forEach(ref => ref.destroy());\n    }\n    /**\n     * A destroyer function for each progress bar instance\n     */\n\n\n    deleteInstance(id) {\n      return () => {\n        this._instances.delete(id);\n      };\n    }\n\n  }\n\n  NgProgress.ɵfac = function NgProgress_Factory(t) {\n    return new (t || NgProgress)(i0.ɵɵinject(NG_PROGRESS_CONFIG, 8));\n  };\n\n  NgProgress.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgProgress,\n    factory: NgProgress.ɵfac,\n    providedIn: 'root'\n  });\n  return NgProgress;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgProgressComponent = /*#__PURE__*/(() => {\n  class NgProgressComponent {\n    constructor(_ngProgress) {\n      this._ngProgress = _ngProgress;\n      /** Creates a new instance if id is not already exists */\n\n      this.id = 'root';\n      /** Initializes inputs from the global config */\n\n      this.min = this._ngProgress.config.min;\n      this.max = this._ngProgress.config.max;\n      this.ease = this._ngProgress.config.ease;\n      this.color = this._ngProgress.config.color;\n      this.speed = this._ngProgress.config.speed;\n      this.thick = this._ngProgress.config.thick;\n      this.fixed = this._ngProgress.config.fixed;\n      this.meteor = this._ngProgress.config.meteor;\n      this.spinner = this._ngProgress.config.spinner;\n      this.trickleSpeed = this._ngProgress.config.trickleSpeed;\n      this.debounceTime = this._ngProgress.config.debounceTime;\n      this.trickleFunc = this._ngProgress.config.trickleFunc;\n      this.spinnerPosition = this._ngProgress.config.spinnerPosition;\n      this.direction = this._ngProgress.config.direction;\n      this.started = new EventEmitter();\n      this.completed = new EventEmitter();\n    }\n\n    get isStarted() {\n      var _a;\n\n      return (_a = this.progressRef) === null || _a === void 0 ? void 0 : _a.isStarted;\n    }\n\n    ngOnChanges() {\n      var _a; // Update progress bar config when inputs change\n\n\n      (_a = this.progressRef) === null || _a === void 0 ? void 0 : _a.setConfig({\n        max: this.max > 0 && this.max <= 100 ? this.max : 100,\n        min: this.min < 100 && this.min >= 0 ? this.min : 0,\n        speed: this.speed,\n        trickleSpeed: this.trickleSpeed,\n        trickleFunc: this.trickleFunc,\n        debounceTime: this.debounceTime\n      });\n    }\n\n    ngOnInit() {\n      // Get progress bar service instance\n      this.progressRef = this._ngProgress.ref(this.id, {\n        max: this.max,\n        min: this.min,\n        speed: this.speed,\n        trickleSpeed: this.trickleSpeed,\n        debounceTime: this.debounceTime\n      }); // Subscribe to progress state\n\n      this.state$ = this.progressRef.state.pipe(map(state => ({\n        active: state.active,\n        transform: `translate3d(${state.value}%,0,0)`\n      }))); // Subscribes to started and completed events on demand\n\n      if (this.started.observed) {\n        this._started = this.progressRef.started.subscribe(() => this.started.emit());\n      }\n\n      if (this.completed.observed) {\n        this._completed = this.progressRef.completed.subscribe(() => this.completed.emit());\n      }\n    }\n\n    ngOnDestroy() {\n      var _a, _b, _c;\n\n      (_a = this._started) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n      (_b = this._completed) === null || _b === void 0 ? void 0 : _b.unsubscribe();\n      (_c = this.progressRef) === null || _c === void 0 ? void 0 : _c.destroy();\n    }\n\n    start() {\n      this.progressRef.start();\n    }\n\n    complete() {\n      this.progressRef.complete();\n    }\n\n    inc(n) {\n      this.progressRef.inc(n);\n    }\n\n    set(n) {\n      this.progressRef.set(n);\n    }\n\n  }\n\n  NgProgressComponent.ɵfac = function NgProgressComponent_Factory(t) {\n    return new (t || NgProgressComponent)(i0.ɵɵdirectiveInject(NgProgress));\n  };\n\n  NgProgressComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgProgressComponent,\n    selectors: [[\"ng-progress\"]],\n    hostAttrs: [\"role\", \"progressbar\"],\n    hostVars: 4,\n    hostBindings: function NgProgressComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"spinnerPosition\", ctx.spinnerPosition)(\"direction\", ctx.direction)(\"thick\", ctx.thick)(\"fixed\", ctx.fixed);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      min: \"min\",\n      max: \"max\",\n      ease: \"ease\",\n      color: \"color\",\n      speed: \"speed\",\n      thick: \"thick\",\n      fixed: \"fixed\",\n      meteor: \"meteor\",\n      spinner: \"spinner\",\n      trickleSpeed: \"trickleSpeed\",\n      debounceTime: \"debounceTime\",\n      trickleFunc: \"trickleFunc\",\n      spinnerPosition: \"spinnerPosition\",\n      direction: \"direction\"\n    },\n    outputs: {\n      started: \"started\",\n      completed: \"completed\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 2,\n    vars: 3,\n    consts: [[4, \"ngIf\"], [1, \"ng-progress-bar\"], [1, \"ng-bar-placeholder\"], [1, \"ng-bar\"], [\"class\", \"ng-meteor\", 3, \"boxShadow\", 4, \"ngIf\"], [\"class\", \"ng-spinner\", 4, \"ngIf\"], [1, \"ng-meteor\"], [1, \"ng-spinner\"], [1, \"ng-spinner-icon\"]],\n    template: function NgProgressComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, NgProgressComponent_ng_container_0_Template, 6, 11, \"ng-container\", 0);\n        i0.ɵɵpipe(1, \"async\");\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", i0.ɵɵpipeBind1(1, 1, ctx.state$));\n      }\n    },\n    directives: [i2.NgIf],\n    pipes: [i2.AsyncPipe],\n    styles: [\"[_nghost-%COMP%]{z-index:999999;pointer-events:none}[fixed=true][_nghost-%COMP%]   .ng-progress-bar[_ngcontent-%COMP%], [fixed=true][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{position:fixed}[fixed=true][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{top:15px}[fixed=true][spinnerPosition=left][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{left:15px}[fixed=true][spinnerPosition=right][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{right:15px}[thick=true][_nghost-%COMP%]   .ng-spinner-icon[_ngcontent-%COMP%]{width:24px;height:24px;border-width:3px}[thick=true][_nghost-%COMP%]   .ng-bar-placeholder[_ngcontent-%COMP%]{height:3px!important}[direction=\\\"ltr+\\\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=ltr-][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{transform:rotate(3deg)}[direction=\\\"ltr+\\\"][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=ltr-][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{transform:rotate(4deg)}[direction=\\\"ltr+\\\"][_nghost-%COMP%]   .ng-bar[_ngcontent-%COMP%], [direction=\\\"rtl+\\\"][_nghost-%COMP%]   .ng-bar[_ngcontent-%COMP%]{margin-left:-100%}[direction=\\\"ltr+\\\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=\\\"rtl+\\\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{right:0}[direction=\\\"ltr+\\\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=rtl-][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{top:-3px}[direction=\\\"ltr+\\\"][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=rtl-][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{top:-4px}[direction=ltr-][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=\\\"rtl+\\\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{bottom:-3px}[direction=ltr-][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=\\\"rtl+\\\"][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{bottom:-4px}[direction=ltr-][_nghost-%COMP%]   .ng-bar-placeholder[_ngcontent-%COMP%], [direction=\\\"rtl+\\\"][_nghost-%COMP%]   .ng-bar-placeholder[_ngcontent-%COMP%]{transform:rotate(180deg)}[direction=ltr-][_nghost-%COMP%]   .ng-spinner-icon[_ngcontent-%COMP%], [direction=\\\"rtl+\\\"][_nghost-%COMP%]   .ng-spinner-icon[_ngcontent-%COMP%]{animation-directionection:reverse}[direction=\\\"rtl+\\\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=rtl-][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{transform:rotate(-3deg)}[direction=\\\"rtl+\\\"][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=rtl-][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{transform:rotate(-4deg)}[spinnerPosition=left][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{left:10px}[spinnerPosition=right][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{right:10px}.ng-progress-bar[_ngcontent-%COMP%]{position:relative;z-index:999999;top:0;left:0;width:100%;transform:scale(1);filter:alpha(opacity=0);opacity:0}.ng-progress-bar[active=true][_ngcontent-%COMP%]{filter:alpha(opacity=100);opacity:1;transition:none}.ng-bar-placeholder[_ngcontent-%COMP%]{position:absolute;height:2px;width:100%}.ng-bar[_ngcontent-%COMP%]{width:100%;height:100%;transform:translate(-100%,0,0)}.ng-meteor[_ngcontent-%COMP%]{display:block;position:absolute;width:100px;height:100%;opacity:1}.ng-spinner[_ngcontent-%COMP%]{position:absolute;display:block;z-index:1031;top:10px}.ng-spinner-icon[_ngcontent-%COMP%]{width:18px;height:18px;box-sizing:border-box;-webkit-animation:spinner-animation .25s linear infinite;animation:spinner-animation .25s linear infinite;border:2px solid transparent;border-radius:50%}@-webkit-keyframes spinner-animation{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes spinner-animation{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\"],\n    changeDetection: 0\n  });\n  return NgProgressComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgProgressModule = /*#__PURE__*/(() => {\n  class NgProgressModule {\n    static withConfig(config) {\n      return {\n        ngModule: NgProgressModule,\n        providers: [{\n          provide: NG_PROGRESS_CONFIG,\n          useValue: config\n        }]\n      };\n    }\n\n  }\n\n  NgProgressModule.ɵfac = function NgProgressModule_Factory(t) {\n    return new (t || NgProgressModule)();\n  };\n\n  NgProgressModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgProgressModule\n  });\n  NgProgressModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return NgProgressModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of ngx-progressbar\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NG_PROGRESS_CONFIG, NgProgress, NgProgressComponent, NgProgressModule, NgProgressRef }; //# sourceMappingURL=ngx-progressbar.mjs.map","map":null,"metadata":{},"sourceType":"module"}