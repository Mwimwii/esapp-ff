{"ast":null,"code":"import _get from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\get.js\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\getPrototypeOf.js\";\nimport _inherits from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\inherits.js\";\nimport _createSuper from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createSuper.js\";\nimport _defineProperty from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\defineProperty.js\";\nimport _toConsumableArray from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\toConsumableArray.js\";\nimport _slicedToArray from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\slicedToArray.js\";\nimport _classCallCheck from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport { __decorate } from 'tslib';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Optional, ViewChild, TemplateRef, Host, Input, Output, Component, ChangeDetectionStrategy, ViewEncapsulation, NgModule } from '@angular/core';\nimport { zoomBigMotion } from 'ng-zorro-antd/core/animation';\nimport { isPresetColor } from 'ng-zorro-antd/core/color';\nimport { toBoolean, isNotNil, InputBoolean } from 'ng-zorro-antd/core/util';\nimport { Subject } from 'rxjs';\nimport { distinctUntilChanged, takeUntil } from 'rxjs/operators';\nimport * as i4 from 'ng-zorro-antd/core/overlay';\nimport { DEFAULT_TOOLTIP_POSITIONS, POSITION_MAP, getPlacementName, NzOverlayModule } from 'ng-zorro-antd/core/overlay';\nimport * as i1 from 'ng-zorro-antd/core/no-animation';\nimport { NzNoAnimationModule } from 'ng-zorro-antd/core/no-animation';\nimport * as i2 from 'ng-zorro-antd/core/config';\nimport * as i3 from '@angular/cdk/bidi';\nimport { BidiModule } from '@angular/cdk/bidi';\nimport * as i3$1 from '@angular/cdk/overlay';\nimport { OverlayModule } from '@angular/cdk/overlay';\nimport * as i5 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i6 from 'ng-zorro-antd/core/outlet';\nimport { NzOutletModule } from 'ng-zorro-antd/core/outlet';\nvar _c0 = [\"overlay\"];\n\nfunction NzToolTipComponent_ng_template_0_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r2.nzTitle);\n  }\n}\n\nfunction NzToolTipComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 2)(1, \"div\", 3)(2, \"div\", 4);\n    i0.ɵɵelement(3, \"span\", 5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"div\", 6);\n    i0.ɵɵtemplate(5, NzToolTipComponent_ng_template_0_ng_container_5_Template, 2, 1, \"ng-container\", 7);\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"ant-tooltip-rtl\", ctx_r1.dir === \"rtl\");\n    i0.ɵɵproperty(\"ngClass\", ctx_r1._classMap)(\"ngStyle\", ctx_r1.nzOverlayStyle)(\"@.disabled\", ctx_r1.noAnimation == null ? null : ctx_r1.noAnimation.nzNoAnimation)(\"nzNoAnimation\", ctx_r1.noAnimation == null ? null : ctx_r1.noAnimation.nzNoAnimation)(\"@zoomBigMotion\", \"active\");\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngStyle\", ctx_r1._contentStyleMap);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngStyle\", ctx_r1._contentStyleMap);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"nzStringTemplateOutlet\", ctx_r1.nzTitle)(\"nzStringTemplateOutletContext\", ctx_r1.nzTitleContext);\n  }\n}\n\nvar NzTooltipBaseDirective = /*#__PURE__*/function () {\n  function NzTooltipBaseDirective(elementRef, hostView, resolver, renderer, noAnimation, nzConfigService) {\n    _classCallCheck(this, NzTooltipBaseDirective);\n\n    this.elementRef = elementRef;\n    this.hostView = hostView;\n    this.resolver = resolver;\n    this.renderer = renderer;\n    this.noAnimation = noAnimation;\n    this.nzConfigService = nzConfigService;\n    this.visibleChange = new EventEmitter();\n    this.internalVisible = false;\n    this.destroy$ = new Subject();\n    this.triggerDisposables = [];\n  }\n  /**\n   * This true title that would be used in other parts on this component.\n   */\n\n\n  _createClass(NzTooltipBaseDirective, [{\n    key: \"_title\",\n    get: function get() {\n      return this.title || this.directiveTitle || null;\n    }\n  }, {\n    key: \"_content\",\n    get: function get() {\n      return this.content || this.directiveContent || null;\n    }\n  }, {\n    key: \"_trigger\",\n    get: function get() {\n      return typeof this.trigger !== 'undefined' ? this.trigger : 'hover';\n    }\n  }, {\n    key: \"_placement\",\n    get: function get() {\n      var p = this.placement;\n      return Array.isArray(p) && p.length > 0 ? p : typeof p === 'string' && p ? [p] : ['top'];\n    }\n  }, {\n    key: \"_visible\",\n    get: function get() {\n      return (typeof this.visible !== 'undefined' ? this.visible : this.internalVisible) || false;\n    }\n  }, {\n    key: \"_mouseEnterDelay\",\n    get: function get() {\n      return this.mouseEnterDelay || 0.15;\n    }\n  }, {\n    key: \"_mouseLeaveDelay\",\n    get: function get() {\n      return this.mouseLeaveDelay || 0.1;\n    }\n  }, {\n    key: \"_overlayClassName\",\n    get: function get() {\n      return this.overlayClassName || null;\n    }\n  }, {\n    key: \"_overlayStyle\",\n    get: function get() {\n      return this.overlayStyle || null;\n    }\n  }, {\n    key: \"getProxyPropertyMap\",\n    value: function getProxyPropertyMap() {\n      var _this = this;\n\n      return {\n        noAnimation: ['noAnimation', function () {\n          return !!_this.noAnimation;\n        }]\n      };\n    }\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(changes) {\n      var trigger = changes.trigger;\n\n      if (trigger && !trigger.isFirstChange()) {\n        this.registerTriggers();\n      }\n\n      if (this.component) {\n        this.updatePropertiesByChanges(changes);\n      }\n    }\n  }, {\n    key: \"ngAfterViewInit\",\n    value: function ngAfterViewInit() {\n      this.createComponent();\n      this.registerTriggers();\n    }\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete(); // Clear toggling timer. Issue #3875 #4317 #4386\n\n      this.clearTogglingTimer();\n      this.removeTriggerListeners();\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      var _a;\n\n      (_a = this.component) === null || _a === void 0 ? void 0 : _a.show();\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var _a;\n\n      (_a = this.component) === null || _a === void 0 ? void 0 : _a.hide();\n    }\n    /**\n     * Force the component to update its position.\n     */\n\n  }, {\n    key: \"updatePosition\",\n    value: function updatePosition() {\n      if (this.component) {\n        this.component.updatePosition();\n      }\n    }\n    /**\n     * Create a dynamic tooltip component. This method can be override.\n     */\n\n  }, {\n    key: \"createComponent\",\n    value: function createComponent() {\n      var _this2 = this;\n\n      var componentRef = this.componentRef;\n      this.component = componentRef.instance; // Remove the component's DOM because it should be in the overlay container.\n\n      this.renderer.removeChild(this.renderer.parentNode(this.elementRef.nativeElement), componentRef.location.nativeElement);\n      this.component.setOverlayOrigin(this.origin || this.elementRef);\n      this.initProperties();\n      this.component.nzVisibleChange.pipe(distinctUntilChanged(), takeUntil(this.destroy$)).subscribe(function (visible) {\n        _this2.internalVisible = visible;\n\n        _this2.visibleChange.emit(visible);\n      });\n    }\n  }, {\n    key: \"registerTriggers\",\n    value: function registerTriggers() {\n      var _this3 = this;\n\n      // When the method gets invoked, all properties has been synced to the dynamic component.\n      // After removing the old API, we can just check the directive's own `nzTrigger`.\n      var el = this.elementRef.nativeElement;\n      var trigger = this.trigger;\n      this.removeTriggerListeners();\n\n      if (trigger === 'hover') {\n        var overlayElement;\n        this.triggerDisposables.push(this.renderer.listen(el, 'mouseenter', function () {\n          _this3.delayEnterLeave(true, true, _this3._mouseEnterDelay);\n        }));\n        this.triggerDisposables.push(this.renderer.listen(el, 'mouseleave', function () {\n          var _a;\n\n          _this3.delayEnterLeave(true, false, _this3._mouseLeaveDelay);\n\n          if (((_a = _this3.component) === null || _a === void 0 ? void 0 : _a.overlay.overlayRef) && !overlayElement) {\n            overlayElement = _this3.component.overlay.overlayRef.overlayElement;\n\n            _this3.triggerDisposables.push(_this3.renderer.listen(overlayElement, 'mouseenter', function () {\n              _this3.delayEnterLeave(false, true, _this3._mouseEnterDelay);\n            }));\n\n            _this3.triggerDisposables.push(_this3.renderer.listen(overlayElement, 'mouseleave', function () {\n              _this3.delayEnterLeave(false, false, _this3._mouseLeaveDelay);\n            }));\n          }\n        }));\n      } else if (trigger === 'focus') {\n        this.triggerDisposables.push(this.renderer.listen(el, 'focusin', function () {\n          return _this3.show();\n        }));\n        this.triggerDisposables.push(this.renderer.listen(el, 'focusout', function () {\n          return _this3.hide();\n        }));\n      } else if (trigger === 'click') {\n        this.triggerDisposables.push(this.renderer.listen(el, 'click', function (e) {\n          e.preventDefault();\n\n          _this3.show();\n        }));\n      } // Else do nothing because user wants to control the visibility programmatically.\n\n    }\n  }, {\n    key: \"updatePropertiesByChanges\",\n    value: function updatePropertiesByChanges(changes) {\n      this.updatePropertiesByKeys(Object.keys(changes));\n    }\n  }, {\n    key: \"updatePropertiesByKeys\",\n    value: function updatePropertiesByKeys(keys) {\n      var _this4 = this;\n\n      var _a;\n\n      var mappingProperties = Object.assign({\n        // common mappings\n        title: ['nzTitle', function () {\n          return _this4._title;\n        }],\n        directiveTitle: ['nzTitle', function () {\n          return _this4._title;\n        }],\n        content: ['nzContent', function () {\n          return _this4._content;\n        }],\n        directiveContent: ['nzContent', function () {\n          return _this4._content;\n        }],\n        trigger: ['nzTrigger', function () {\n          return _this4._trigger;\n        }],\n        placement: ['nzPlacement', function () {\n          return _this4._placement;\n        }],\n        visible: ['nzVisible', function () {\n          return _this4._visible;\n        }],\n        mouseEnterDelay: ['nzMouseEnterDelay', function () {\n          return _this4._mouseEnterDelay;\n        }],\n        mouseLeaveDelay: ['nzMouseLeaveDelay', function () {\n          return _this4._mouseLeaveDelay;\n        }],\n        overlayClassName: ['nzOverlayClassName', function () {\n          return _this4._overlayClassName;\n        }],\n        overlayStyle: ['nzOverlayStyle', function () {\n          return _this4._overlayStyle;\n        }],\n        arrowPointAtCenter: ['nzArrowPointAtCenter', function () {\n          return _this4.arrowPointAtCenter;\n        }]\n      }, this.getProxyPropertyMap());\n      (keys || Object.keys(mappingProperties).filter(function (key) {\n        return !key.startsWith('directive');\n      })).forEach(function (property) {\n        if (mappingProperties[property]) {\n          var _mappingProperties$pr = _slicedToArray(mappingProperties[property], 2),\n              name = _mappingProperties$pr[0],\n              valueFn = _mappingProperties$pr[1];\n\n          _this4.updateComponentValue(name, valueFn());\n        }\n      });\n      (_a = this.component) === null || _a === void 0 ? void 0 : _a.updateByDirective();\n    }\n  }, {\n    key: \"initProperties\",\n    value: function initProperties() {\n      this.updatePropertiesByKeys();\n    }\n  }, {\n    key: \"updateComponentValue\",\n    value: function updateComponentValue(key, value) {\n      if (typeof value !== 'undefined') {\n        // @ts-ignore\n        this.component[key] = value;\n      }\n    }\n  }, {\n    key: \"delayEnterLeave\",\n    value: function delayEnterLeave(isOrigin, isEnter) {\n      var _this5 = this;\n\n      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n      if (this.delayTimer) {\n        this.clearTogglingTimer();\n      } else if (delay > 0) {\n        this.delayTimer = setTimeout(function () {\n          _this5.delayTimer = undefined;\n          isEnter ? _this5.show() : _this5.hide();\n        }, delay * 1000);\n      } else {\n        // `isOrigin` is used due to the tooltip will not hide immediately\n        // (may caused by the fade-out animation).\n        isEnter && isOrigin ? this.show() : this.hide();\n      }\n    }\n  }, {\n    key: \"removeTriggerListeners\",\n    value: function removeTriggerListeners() {\n      this.triggerDisposables.forEach(function (dispose) {\n        return dispose();\n      });\n      this.triggerDisposables.length = 0;\n    }\n  }, {\n    key: \"clearTogglingTimer\",\n    value: function clearTogglingTimer() {\n      if (this.delayTimer) {\n        clearTimeout(this.delayTimer);\n        this.delayTimer = undefined;\n      }\n    }\n  }]);\n\n  return NzTooltipBaseDirective;\n}();\n\nNzTooltipBaseDirective.ɵfac = function NzTooltipBaseDirective_Factory(t) {\n  return new (t || NzTooltipBaseDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.NzNoAnimationDirective), i0.ɵɵdirectiveInject(i2.NzConfigService));\n};\n\nNzTooltipBaseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: NzTooltipBaseDirective,\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NzTooltipBaseDirective, [{\n    type: Directive\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.ViewContainerRef\n    }, {\n      type: i0.ComponentFactoryResolver\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: i1.NzNoAnimationDirective\n    }, {\n      type: i2.NzConfigService\n    }];\n  }, null);\n})(); // eslint-disable-next-line @angular-eslint/directive-class-suffix\n\n\nvar NzTooltipBaseComponent = /*#__PURE__*/function () {\n  function NzTooltipBaseComponent(cdr, directionality, noAnimation) {\n    _classCallCheck(this, NzTooltipBaseComponent);\n\n    this.cdr = cdr;\n    this.directionality = directionality;\n    this.noAnimation = noAnimation;\n    this.nzTitle = null;\n    this.nzContent = null;\n    this.nzArrowPointAtCenter = false;\n    this.nzOverlayStyle = {};\n    this.nzBackdrop = false;\n    this.nzVisibleChange = new Subject();\n    this._visible = false;\n    this._trigger = 'hover';\n    this.preferredPlacement = 'top';\n    this.dir = 'ltr';\n    this._classMap = {};\n    this._prefix = 'ant-tooltip';\n    this._positions = _toConsumableArray(DEFAULT_TOOLTIP_POSITIONS);\n    this.destroy$ = new Subject();\n  }\n\n  _createClass(NzTooltipBaseComponent, [{\n    key: \"nzVisible\",\n    get: function get() {\n      return this._visible;\n    },\n    set: function set(value) {\n      var visible = toBoolean(value);\n\n      if (this._visible !== visible) {\n        this._visible = visible;\n        this.nzVisibleChange.next(visible);\n      }\n    }\n  }, {\n    key: \"nzTrigger\",\n    get: function get() {\n      return this._trigger;\n    },\n    set: function set(value) {\n      this._trigger = value;\n    }\n  }, {\n    key: \"nzPlacement\",\n    set: function set(value) {\n      var preferredPosition = value.map(function (placement) {\n        return POSITION_MAP[placement];\n      });\n      this._positions = [].concat(_toConsumableArray(preferredPosition), _toConsumableArray(DEFAULT_TOOLTIP_POSITIONS));\n    }\n  }, {\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      var _this6 = this;\n\n      var _a;\n\n      (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe(function (direction) {\n        _this6.dir = direction;\n\n        _this6.cdr.detectChanges();\n      });\n      this.dir = this.directionality.value;\n    }\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.nzVisibleChange.complete();\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      if (this.nzVisible) {\n        return;\n      }\n\n      if (!this.isEmpty()) {\n        this.nzVisible = true;\n        this.nzVisibleChange.next(true);\n        this.cdr.detectChanges();\n      } // for ltr for overlay to display tooltip in correct placement in rtl direction.\n\n\n      if (this.origin && this.overlay && this.overlay.overlayRef && this.overlay.overlayRef.getDirection() === 'rtl') {\n        this.overlay.overlayRef.setDirection('ltr');\n      }\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      if (!this.nzVisible) {\n        return;\n      }\n\n      this.nzVisible = false;\n      this.nzVisibleChange.next(false);\n      this.cdr.detectChanges();\n    }\n  }, {\n    key: \"updateByDirective\",\n    value: function updateByDirective() {\n      var _this7 = this;\n\n      this.updateStyles();\n      this.cdr.detectChanges();\n      Promise.resolve().then(function () {\n        _this7.updatePosition();\n\n        _this7.updateVisibilityByTitle();\n      });\n    }\n    /**\n     * Force the component to update its position.\n     */\n\n  }, {\n    key: \"updatePosition\",\n    value: function updatePosition() {\n      if (this.origin && this.overlay && this.overlay.overlayRef) {\n        this.overlay.overlayRef.updatePosition();\n      }\n    }\n  }, {\n    key: \"onPositionChange\",\n    value: function onPositionChange(position) {\n      this.preferredPlacement = getPlacementName(position);\n      this.updateStyles(); // We have to trigger immediate change detection or the element would blink.\n\n      this.cdr.detectChanges();\n    }\n  }, {\n    key: \"setOverlayOrigin\",\n    value: function setOverlayOrigin(origin) {\n      this.origin = origin;\n      this.cdr.markForCheck();\n    }\n  }, {\n    key: \"onClickOutside\",\n    value: function onClickOutside(event) {\n      if (!this.origin.nativeElement.contains(event.target) && this.nzTrigger !== null) {\n        this.hide();\n      }\n    }\n    /**\n     * Hide the component while the content is empty.\n     */\n\n  }, {\n    key: \"updateVisibilityByTitle\",\n    value: function updateVisibilityByTitle() {\n      if (this.isEmpty()) {\n        this.hide();\n      }\n    }\n  }, {\n    key: \"updateStyles\",\n    value: function updateStyles() {\n      var _this$_classMap;\n\n      this._classMap = (_this$_classMap = {}, _defineProperty(_this$_classMap, this.nzOverlayClassName, true), _defineProperty(_this$_classMap, \"\".concat(this._prefix, \"-placement-\").concat(this.preferredPlacement), true), _this$_classMap);\n    }\n  }]);\n\n  return NzTooltipBaseComponent;\n}();\n\nNzTooltipBaseComponent.ɵfac = function NzTooltipBaseComponent_Factory(t) {\n  return new (t || NzTooltipBaseComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i3.Directionality, 8), i0.ɵɵdirectiveInject(i1.NzNoAnimationDirective));\n};\n\nNzTooltipBaseComponent.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: NzTooltipBaseComponent,\n  viewQuery: function NzTooltipBaseComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c0, 5);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overlay = _t.first);\n    }\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NzTooltipBaseComponent, [{\n    type: Directive\n  }], function () {\n    return [{\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i3.Directionality,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: i1.NzNoAnimationDirective\n    }];\n  }, {\n    overlay: [{\n      type: ViewChild,\n      args: ['overlay', {\n        static: false\n      }]\n    }]\n  });\n})();\n\nfunction isTooltipEmpty(value) {\n  return value instanceof TemplateRef ? false : value === '' || !isNotNil(value);\n}\n\nvar NzTooltipDirective = /*#__PURE__*/function (_NzTooltipBaseDirecti) {\n  _inherits(NzTooltipDirective, _NzTooltipBaseDirecti);\n\n  var _super = _createSuper(NzTooltipDirective);\n\n  function NzTooltipDirective(elementRef, hostView, resolver, renderer, noAnimation) {\n    var _this8;\n\n    _classCallCheck(this, NzTooltipDirective);\n\n    _this8 = _super.call(this, elementRef, hostView, resolver, renderer, noAnimation);\n    _this8.titleContext = null;\n    _this8.trigger = 'hover';\n    _this8.placement = 'top'; // eslint-disable-next-line @angular-eslint/no-output-rename\n\n    _this8.visibleChange = new EventEmitter();\n    _this8.componentRef = _this8.hostView.createComponent(NzToolTipComponent);\n    return _this8;\n  }\n\n  _createClass(NzTooltipDirective, [{\n    key: \"getProxyPropertyMap\",\n    value: function getProxyPropertyMap() {\n      var _this9 = this;\n\n      return Object.assign(Object.assign({}, _get(_getPrototypeOf(NzTooltipDirective.prototype), \"getProxyPropertyMap\", this).call(this)), {\n        nzTooltipColor: ['nzColor', function () {\n          return _this9.nzTooltipColor;\n        }],\n        nzTooltipTitleContext: ['nzTitleContext', function () {\n          return _this9.titleContext;\n        }]\n      });\n    }\n  }]);\n\n  return NzTooltipDirective;\n}(NzTooltipBaseDirective);\n\nNzTooltipDirective.ɵfac = function NzTooltipDirective_Factory(t) {\n  return new (t || NzTooltipDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.NzNoAnimationDirective, 9));\n};\n\nNzTooltipDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: NzTooltipDirective,\n  selectors: [[\"\", \"nz-tooltip\", \"\"]],\n  hostVars: 2,\n  hostBindings: function NzTooltipDirective_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵclassProp(\"ant-tooltip-open\", ctx.visible);\n    }\n  },\n  inputs: {\n    title: [\"nzTooltipTitle\", \"title\"],\n    titleContext: [\"nzTooltipTitleContext\", \"titleContext\"],\n    directiveTitle: [\"nz-tooltip\", \"directiveTitle\"],\n    trigger: [\"nzTooltipTrigger\", \"trigger\"],\n    placement: [\"nzTooltipPlacement\", \"placement\"],\n    origin: [\"nzTooltipOrigin\", \"origin\"],\n    visible: [\"nzTooltipVisible\", \"visible\"],\n    mouseEnterDelay: [\"nzTooltipMouseEnterDelay\", \"mouseEnterDelay\"],\n    mouseLeaveDelay: [\"nzTooltipMouseLeaveDelay\", \"mouseLeaveDelay\"],\n    overlayClassName: [\"nzTooltipOverlayClassName\", \"overlayClassName\"],\n    overlayStyle: [\"nzTooltipOverlayStyle\", \"overlayStyle\"],\n    arrowPointAtCenter: [\"nzTooltipArrowPointAtCenter\", \"arrowPointAtCenter\"],\n    nzTooltipColor: \"nzTooltipColor\"\n  },\n  outputs: {\n    visibleChange: \"nzTooltipVisibleChange\"\n  },\n  exportAs: [\"nzTooltip\"],\n  features: [i0.ɵɵInheritDefinitionFeature]\n});\n\n__decorate([InputBoolean()], NzTooltipDirective.prototype, \"arrowPointAtCenter\", void 0);\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NzTooltipDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[nz-tooltip]',\n      exportAs: 'nzTooltip',\n      host: {\n        '[class.ant-tooltip-open]': 'visible'\n      }\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.ViewContainerRef\n    }, {\n      type: i0.ComponentFactoryResolver\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: i1.NzNoAnimationDirective,\n      decorators: [{\n        type: Host\n      }, {\n        type: Optional\n      }]\n    }];\n  }, {\n    title: [{\n      type: Input,\n      args: ['nzTooltipTitle']\n    }],\n    titleContext: [{\n      type: Input,\n      args: ['nzTooltipTitleContext']\n    }],\n    directiveTitle: [{\n      type: Input,\n      args: ['nz-tooltip']\n    }],\n    trigger: [{\n      type: Input,\n      args: ['nzTooltipTrigger']\n    }],\n    placement: [{\n      type: Input,\n      args: ['nzTooltipPlacement']\n    }],\n    origin: [{\n      type: Input,\n      args: ['nzTooltipOrigin']\n    }],\n    visible: [{\n      type: Input,\n      args: ['nzTooltipVisible']\n    }],\n    mouseEnterDelay: [{\n      type: Input,\n      args: ['nzTooltipMouseEnterDelay']\n    }],\n    mouseLeaveDelay: [{\n      type: Input,\n      args: ['nzTooltipMouseLeaveDelay']\n    }],\n    overlayClassName: [{\n      type: Input,\n      args: ['nzTooltipOverlayClassName']\n    }],\n    overlayStyle: [{\n      type: Input,\n      args: ['nzTooltipOverlayStyle']\n    }],\n    arrowPointAtCenter: [{\n      type: Input,\n      args: ['nzTooltipArrowPointAtCenter']\n    }],\n    nzTooltipColor: [{\n      type: Input\n    }],\n    visibleChange: [{\n      type: Output,\n      args: ['nzTooltipVisibleChange']\n    }]\n  });\n})();\n\nvar NzToolTipComponent = /*#__PURE__*/function (_NzTooltipBaseCompone) {\n  _inherits(NzToolTipComponent, _NzTooltipBaseCompone);\n\n  var _super2 = _createSuper(NzToolTipComponent);\n\n  function NzToolTipComponent(cdr, directionality, noAnimation) {\n    var _this10;\n\n    _classCallCheck(this, NzToolTipComponent);\n\n    _this10 = _super2.call(this, cdr, directionality, noAnimation);\n    _this10.nzTitle = null;\n    _this10.nzTitleContext = null;\n    _this10._contentStyleMap = {};\n    return _this10;\n  }\n\n  _createClass(NzToolTipComponent, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return isTooltipEmpty(this.nzTitle);\n    }\n  }, {\n    key: \"updateStyles\",\n    value: function updateStyles() {\n      var _this$_classMap2;\n\n      var isColorPreset = this.nzColor && isPresetColor(this.nzColor);\n      this._classMap = (_this$_classMap2 = {}, _defineProperty(_this$_classMap2, this.nzOverlayClassName, true), _defineProperty(_this$_classMap2, \"\".concat(this._prefix, \"-placement-\").concat(this.preferredPlacement), true), _defineProperty(_this$_classMap2, \"\".concat(this._prefix, \"-\").concat(this.nzColor), isColorPreset), _this$_classMap2);\n      this._contentStyleMap = {\n        backgroundColor: !!this.nzColor && !isColorPreset ? this.nzColor : null\n      };\n    }\n  }]);\n\n  return NzToolTipComponent;\n}(NzTooltipBaseComponent);\n\nNzToolTipComponent.ɵfac = function NzToolTipComponent_Factory(t) {\n  return new (t || NzToolTipComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i3.Directionality, 8), i0.ɵɵdirectiveInject(i1.NzNoAnimationDirective, 9));\n};\n\nNzToolTipComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: NzToolTipComponent,\n  selectors: [[\"nz-tooltip\"]],\n  exportAs: [\"nzTooltipComponent\"],\n  features: [i0.ɵɵInheritDefinitionFeature],\n  decls: 2,\n  vars: 5,\n  consts: [[\"cdkConnectedOverlay\", \"\", \"nzConnectedOverlay\", \"\", 3, \"cdkConnectedOverlayOrigin\", \"cdkConnectedOverlayOpen\", \"cdkConnectedOverlayPositions\", \"cdkConnectedOverlayPush\", \"nzArrowPointAtCenter\", \"overlayOutsideClick\", \"detach\", \"positionChange\"], [\"overlay\", \"cdkConnectedOverlay\"], [1, \"ant-tooltip\", 3, \"ngClass\", \"ngStyle\", \"nzNoAnimation\"], [1, \"ant-tooltip-content\"], [1, \"ant-tooltip-arrow\"], [1, \"ant-tooltip-arrow-content\", 3, \"ngStyle\"], [1, \"ant-tooltip-inner\", 3, \"ngStyle\"], [4, \"nzStringTemplateOutlet\", \"nzStringTemplateOutletContext\"]],\n  template: function NzToolTipComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵtemplate(0, NzToolTipComponent_ng_template_0_Template, 6, 11, \"ng-template\", 0, 1, i0.ɵɵtemplateRefExtractor);\n      i0.ɵɵlistener(\"overlayOutsideClick\", function NzToolTipComponent_Template_ng_template_overlayOutsideClick_0_listener($event) {\n        return ctx.onClickOutside($event);\n      })(\"detach\", function NzToolTipComponent_Template_ng_template_detach_0_listener() {\n        return ctx.hide();\n      })(\"positionChange\", function NzToolTipComponent_Template_ng_template_positionChange_0_listener($event) {\n        return ctx.onPositionChange($event);\n      });\n    }\n\n    if (rf & 2) {\n      i0.ɵɵproperty(\"cdkConnectedOverlayOrigin\", ctx.origin)(\"cdkConnectedOverlayOpen\", ctx._visible)(\"cdkConnectedOverlayPositions\", ctx._positions)(\"cdkConnectedOverlayPush\", true)(\"nzArrowPointAtCenter\", ctx.nzArrowPointAtCenter);\n    }\n  },\n  directives: [i3$1.CdkConnectedOverlay, i4.NzConnectedOverlayDirective, i5.NgClass, i5.NgStyle, i1.NzNoAnimationDirective, i6.NzStringTemplateOutletDirective],\n  encapsulation: 2,\n  data: {\n    animation: [zoomBigMotion]\n  },\n  changeDetection: 0\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NzToolTipComponent, [{\n    type: Component,\n    args: [{\n      selector: 'nz-tooltip',\n      exportAs: 'nzTooltipComponent',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      encapsulation: ViewEncapsulation.None,\n      animations: [zoomBigMotion],\n      template: \"\\n    <ng-template\\n      #overlay=\\\"cdkConnectedOverlay\\\"\\n      cdkConnectedOverlay\\n      nzConnectedOverlay\\n      [cdkConnectedOverlayOrigin]=\\\"origin\\\"\\n      [cdkConnectedOverlayOpen]=\\\"_visible\\\"\\n      [cdkConnectedOverlayPositions]=\\\"_positions\\\"\\n      [cdkConnectedOverlayPush]=\\\"true\\\"\\n      [nzArrowPointAtCenter]=\\\"nzArrowPointAtCenter\\\"\\n      (overlayOutsideClick)=\\\"onClickOutside($event)\\\"\\n      (detach)=\\\"hide()\\\"\\n      (positionChange)=\\\"onPositionChange($event)\\\"\\n    >\\n      <div\\n        class=\\\"ant-tooltip\\\"\\n        [class.ant-tooltip-rtl]=\\\"dir === 'rtl'\\\"\\n        [ngClass]=\\\"_classMap\\\"\\n        [ngStyle]=\\\"nzOverlayStyle\\\"\\n        [@.disabled]=\\\"noAnimation?.nzNoAnimation\\\"\\n        [nzNoAnimation]=\\\"noAnimation?.nzNoAnimation\\\"\\n        [@zoomBigMotion]=\\\"'active'\\\"\\n      >\\n        <div class=\\\"ant-tooltip-content\\\">\\n          <div class=\\\"ant-tooltip-arrow\\\">\\n            <span class=\\\"ant-tooltip-arrow-content\\\" [ngStyle]=\\\"_contentStyleMap\\\"></span>\\n          </div>\\n          <div class=\\\"ant-tooltip-inner\\\" [ngStyle]=\\\"_contentStyleMap\\\">\\n            <ng-container *nzStringTemplateOutlet=\\\"nzTitle; context: nzTitleContext\\\">{{ nzTitle }}</ng-container>\\n          </div>\\n        </div>\\n      </div>\\n    </ng-template>\\n  \",\n      preserveWhitespaces: false\n    }]\n  }], function () {\n    return [{\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i3.Directionality,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: i1.NzNoAnimationDirective,\n      decorators: [{\n        type: Host\n      }, {\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nvar NzToolTipModule = /*#__PURE__*/_createClass(function NzToolTipModule() {\n  _classCallCheck(this, NzToolTipModule);\n});\n\nNzToolTipModule.ɵfac = function NzToolTipModule_Factory(t) {\n  return new (t || NzToolTipModule)();\n};\n\nNzToolTipModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NzToolTipModule,\n  declarations: [NzToolTipComponent, NzTooltipDirective],\n  imports: [BidiModule, CommonModule, OverlayModule, NzOutletModule, NzOverlayModule, NzNoAnimationModule],\n  exports: [NzToolTipComponent, NzTooltipDirective]\n});\nNzToolTipModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[BidiModule, CommonModule, OverlayModule, NzOutletModule, NzOverlayModule, NzNoAnimationModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NzToolTipModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [NzToolTipComponent, NzTooltipDirective],\n      exports: [NzToolTipComponent, NzTooltipDirective],\n      entryComponents: [NzToolTipComponent],\n      imports: [BidiModule, CommonModule, OverlayModule, NzOutletModule, NzOverlayModule, NzNoAnimationModule]\n    }]\n  }], null, null);\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NzToolTipComponent, NzToolTipModule, NzTooltipBaseComponent, NzTooltipBaseDirective, NzTooltipDirective, isTooltipEmpty }; //# sourceMappingURL=ng-zorro-antd-tooltip.mjs.map","map":null,"metadata":{},"sourceType":"module"}