{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, Inject, ViewChild, Input, Output, TemplateRef, ContentChild, NgModule } from '@angular/core';\nimport { __decorate } from 'tslib';\nimport * as i5 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Subject, fromEvent } from 'rxjs';\nimport { throttleTime, takeUntil } from 'rxjs/operators';\nimport * as i1 from 'ng-zorro-antd/core/config';\nimport { WithConfig } from 'ng-zorro-antd/core/config';\nimport { InputBoolean, InputNumber } from 'ng-zorro-antd/core/util';\nimport * as i2 from 'ng-zorro-antd/core/services';\nimport * as i3 from '@angular/cdk/platform';\nimport { PlatformModule } from '@angular/cdk/platform';\nimport * as i4 from 'ng-zorro-antd/affix';\nimport { NzAffixModule } from 'ng-zorro-antd/affix';\nimport { BidiModule } from '@angular/cdk/bidi';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nvar _c0 = [\"ink\"];\n\nfunction NzAnchorComponent_nz_affix_0_ng_template_1_Template(rf, ctx) {}\n\nfunction NzAnchorComponent_nz_affix_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"nz-affix\", 2);\n    i0.ɵɵtemplate(1, NzAnchorComponent_nz_affix_0_ng_template_1_Template, 0, 0, \"ng-template\", 3);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = i0.ɵɵnextContext();\n\n    var _r1 = i0.ɵɵreference(2);\n\n    i0.ɵɵproperty(\"nzOffsetTop\", ctx_r0.nzOffsetTop)(\"nzTarget\", ctx_r0.container);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r1);\n  }\n}\n\nvar _c1 = function _c1(a0) {\n  return {\n    \"ant-anchor-fixed\": a0\n  };\n};\n\nfunction NzAnchorComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 4)(1, \"div\", 5)(2, \"div\", 6);\n    i0.ɵɵelement(3, \"div\", 7, 8);\n    i0.ɵɵelementEnd();\n    i0.ɵɵprojection(5);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    var ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngStyle\", ctx_r2.wrapperStyle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(2, _c1, !ctx_r2.nzAffix && !ctx_r2.nzShowInkInFixed));\n  }\n}\n\nvar _c2 = [\"*\"];\nvar _c3 = [\"nzTemplate\"];\nvar _c4 = [\"linkTitle\"];\n\nfunction NzAnchorLinkComponent_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.titleStr);\n  }\n}\n\nfunction getOffsetTop(element, container) {\n  if (!element || !element.getClientRects().length) {\n    return 0;\n  }\n\n  var rect = element.getBoundingClientRect();\n\n  if (rect.width || rect.height) {\n    if (container === window) {\n      var documentElement = element.ownerDocument.documentElement;\n      return rect.top - documentElement.clientTop;\n    }\n\n    return rect.top - container.getBoundingClientRect().top;\n  }\n\n  return rect.top;\n}\n\nvar NZ_CONFIG_MODULE_NAME = 'anchor';\nvar sharpMatcherRegx = /#([^#]+)$/;\n\nvar NzAnchorComponent = /*#__PURE__*/function () {\n  function NzAnchorComponent(doc, nzConfigService, scrollSrv, cdr, platform, zone, renderer) {\n    _classCallCheck(this, NzAnchorComponent);\n\n    this.doc = doc;\n    this.nzConfigService = nzConfigService;\n    this.scrollSrv = scrollSrv;\n    this.cdr = cdr;\n    this.platform = platform;\n    this.zone = zone;\n    this.renderer = renderer;\n    this._nzModuleName = NZ_CONFIG_MODULE_NAME;\n    this.nzAffix = true;\n    this.nzShowInkInFixed = false;\n    this.nzBounds = 5;\n    this.nzOffsetTop = undefined;\n    this.nzClick = new EventEmitter();\n    this.nzScroll = new EventEmitter();\n    this.visible = false;\n    this.wrapperStyle = {\n      'max-height': '100vh'\n    };\n    this.links = [];\n    this.animating = false;\n    this.destroy$ = new Subject();\n    this.handleScrollTimeoutID = -1;\n  }\n\n  _createClass(NzAnchorComponent, [{\n    key: \"registerLink\",\n    value: function registerLink(link) {\n      this.links.push(link);\n    }\n  }, {\n    key: \"unregisterLink\",\n    value: function unregisterLink(link) {\n      this.links.splice(this.links.indexOf(link), 1);\n    }\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this.container || window;\n    }\n  }, {\n    key: \"ngAfterViewInit\",\n    value: function ngAfterViewInit() {\n      this.registerScrollEvent();\n    }\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      clearTimeout(this.handleScrollTimeoutID);\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n  }, {\n    key: \"registerScrollEvent\",\n    value: function registerScrollEvent() {\n      var _this = this;\n\n      if (!this.platform.isBrowser) {\n        return;\n      }\n\n      this.destroy$.next();\n      this.zone.runOutsideAngular(function () {\n        fromEvent(_this.getContainer(), 'scroll').pipe(throttleTime(50), takeUntil(_this.destroy$)).subscribe(function () {\n          return _this.handleScroll();\n        });\n      }); // Browser would maintain the scrolling position when refreshing.\n      // So we have to delay calculation in avoid of getting a incorrect result.\n\n      this.handleScrollTimeoutID = setTimeout(function () {\n        return _this.handleScroll();\n      });\n    }\n  }, {\n    key: \"handleScroll\",\n    value: function handleScroll() {\n      var _this2 = this;\n\n      if (typeof document === 'undefined' || this.animating) {\n        return;\n      }\n\n      var sections = [];\n      var scope = (this.nzOffsetTop || 0) + this.nzBounds;\n      this.links.forEach(function (comp) {\n        var sharpLinkMatch = sharpMatcherRegx.exec(comp.nzHref.toString());\n\n        if (!sharpLinkMatch) {\n          return;\n        }\n\n        var target = _this2.doc.getElementById(sharpLinkMatch[1]);\n\n        if (target) {\n          var top = getOffsetTop(target, _this2.getContainer());\n\n          if (top < scope) {\n            sections.push({\n              top: top,\n              comp: comp\n            });\n          }\n        }\n      });\n      this.visible = !!sections.length;\n\n      if (!this.visible) {\n        this.clearActive();\n        this.cdr.detectChanges();\n      } else {\n        var maxSection = sections.reduce(function (prev, curr) {\n          return curr.top > prev.top ? curr : prev;\n        });\n        this.handleActive(maxSection.comp);\n      }\n\n      this.setVisible();\n    }\n  }, {\n    key: \"clearActive\",\n    value: function clearActive() {\n      this.links.forEach(function (i) {\n        i.unsetActive();\n      });\n    }\n  }, {\n    key: \"handleActive\",\n    value: function handleActive(comp) {\n      this.clearActive();\n      comp.setActive();\n      var linkNode = comp.getLinkTitleElement();\n      this.ink.nativeElement.style.top = \"\".concat(linkNode.offsetTop + linkNode.clientHeight / 2 - 4.5, \"px\");\n      this.visible = true;\n      this.setVisible();\n      this.nzScroll.emit(comp);\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible() {\n      var visible = this.visible;\n      var visibleClassname = 'visible';\n\n      if (this.ink) {\n        if (visible) {\n          this.renderer.addClass(this.ink.nativeElement, visibleClassname);\n        } else {\n          this.renderer.removeClass(this.ink.nativeElement, visibleClassname);\n        }\n      }\n    }\n  }, {\n    key: \"handleScrollTo\",\n    value: function handleScrollTo(linkComp) {\n      var _this3 = this;\n\n      var el = this.doc.querySelector(linkComp.nzHref);\n\n      if (!el) {\n        return;\n      }\n\n      this.animating = true;\n      var containerScrollTop = this.scrollSrv.getScroll(this.getContainer());\n      var elOffsetTop = getOffsetTop(el, this.getContainer());\n      var targetScrollTop = containerScrollTop + elOffsetTop - (this.nzOffsetTop || 0);\n      this.scrollSrv.scrollTo(this.getContainer(), targetScrollTop, {\n        callback: function callback() {\n          _this3.animating = false;\n\n          _this3.handleActive(linkComp);\n        }\n      });\n      this.nzClick.emit(linkComp.nzHref);\n    }\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(changes) {\n      var nzOffsetTop = changes.nzOffsetTop,\n          nzContainer = changes.nzContainer;\n\n      if (nzOffsetTop) {\n        this.wrapperStyle = {\n          'max-height': \"calc(100vh - \".concat(this.nzOffsetTop, \"px)\")\n        };\n      }\n\n      if (nzContainer) {\n        var container = this.nzContainer;\n        this.container = typeof container === 'string' ? this.doc.querySelector(container) : container;\n        this.registerScrollEvent();\n      }\n    }\n  }]);\n\n  return NzAnchorComponent;\n}();\n\nNzAnchorComponent.ɵfac = function NzAnchorComponent_Factory(t) {\n  return new (t || NzAnchorComponent)(i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i1.NzConfigService), i0.ɵɵdirectiveInject(i2.NzScrollService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i3.Platform), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2));\n};\n\nNzAnchorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: NzAnchorComponent,\n  selectors: [[\"nz-anchor\"]],\n  viewQuery: function NzAnchorComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c0, 5);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.ink = _t.first);\n    }\n  },\n  inputs: {\n    nzAffix: \"nzAffix\",\n    nzShowInkInFixed: \"nzShowInkInFixed\",\n    nzBounds: \"nzBounds\",\n    nzOffsetTop: \"nzOffsetTop\",\n    nzContainer: \"nzContainer\"\n  },\n  outputs: {\n    nzClick: \"nzClick\",\n    nzScroll: \"nzScroll\"\n  },\n  exportAs: [\"nzAnchor\"],\n  features: [i0.ɵɵNgOnChangesFeature],\n  ngContentSelectors: _c2,\n  decls: 3,\n  vars: 2,\n  consts: [[3, \"nzOffsetTop\", \"nzTarget\", 4, \"ngIf\", \"ngIfElse\"], [\"content\", \"\"], [3, \"nzOffsetTop\", \"nzTarget\"], [3, \"ngTemplateOutlet\"], [1, \"ant-anchor-wrapper\", 3, \"ngStyle\"], [1, \"ant-anchor\", 3, \"ngClass\"], [1, \"ant-anchor-ink\"], [1, \"ant-anchor-ink-ball\"], [\"ink\", \"\"]],\n  template: function NzAnchorComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵtemplate(0, NzAnchorComponent_nz_affix_0_Template, 2, 3, \"nz-affix\", 0);\n      i0.ɵɵtemplate(1, NzAnchorComponent_ng_template_1_Template, 6, 4, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n    }\n\n    if (rf & 2) {\n      var _r1 = i0.ɵɵreference(2);\n\n      i0.ɵɵproperty(\"ngIf\", ctx.nzAffix)(\"ngIfElse\", _r1);\n    }\n  },\n  directives: [i4.NzAffixComponent, i5.NgIf, i5.NgTemplateOutlet, i5.NgStyle, i5.NgClass],\n  encapsulation: 2,\n  changeDetection: 0\n});\n\n__decorate([InputBoolean()], NzAnchorComponent.prototype, \"nzAffix\", void 0);\n\n__decorate([WithConfig(), InputBoolean()], NzAnchorComponent.prototype, \"nzShowInkInFixed\", void 0);\n\n__decorate([WithConfig(), InputNumber()], NzAnchorComponent.prototype, \"nzBounds\", void 0);\n\n__decorate([InputNumber(undefined), WithConfig()], NzAnchorComponent.prototype, \"nzOffsetTop\", void 0);\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NzAnchorComponent, [{\n    type: Component,\n    args: [{\n      selector: 'nz-anchor',\n      exportAs: 'nzAnchor',\n      preserveWhitespaces: false,\n      template: \"\\n    <nz-affix *ngIf=\\\"nzAffix; else content\\\" [nzOffsetTop]=\\\"nzOffsetTop\\\" [nzTarget]=\\\"container\\\">\\n      <ng-template [ngTemplateOutlet]=\\\"content\\\"></ng-template>\\n    </nz-affix>\\n    <ng-template #content>\\n      <div class=\\\"ant-anchor-wrapper\\\" [ngStyle]=\\\"wrapperStyle\\\">\\n        <div class=\\\"ant-anchor\\\" [ngClass]=\\\"{ 'ant-anchor-fixed': !nzAffix && !nzShowInkInFixed }\\\">\\n          <div class=\\\"ant-anchor-ink\\\">\\n            <div class=\\\"ant-anchor-ink-ball\\\" #ink></div>\\n          </div>\\n          <ng-content></ng-content>\\n        </div>\\n      </div>\\n    </ng-template>\\n  \",\n      encapsulation: ViewEncapsulation.None,\n      changeDetection: ChangeDetectionStrategy.OnPush\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: i1.NzConfigService\n    }, {\n      type: i2.NzScrollService\n    }, {\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i3.Platform\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i0.Renderer2\n    }];\n  }, {\n    ink: [{\n      type: ViewChild,\n      args: ['ink', {\n        static: false\n      }]\n    }],\n    nzAffix: [{\n      type: Input\n    }],\n    nzShowInkInFixed: [{\n      type: Input\n    }],\n    nzBounds: [{\n      type: Input\n    }],\n    nzOffsetTop: [{\n      type: Input\n    }],\n    nzContainer: [{\n      type: Input\n    }],\n    nzClick: [{\n      type: Output\n    }],\n    nzScroll: [{\n      type: Output\n    }]\n  });\n})();\n\nvar NzAnchorLinkComponent = /*#__PURE__*/function () {\n  function NzAnchorLinkComponent(elementRef, anchorComp, platform, renderer) {\n    _classCallCheck(this, NzAnchorLinkComponent);\n\n    this.elementRef = elementRef;\n    this.anchorComp = anchorComp;\n    this.platform = platform;\n    this.renderer = renderer;\n    this.nzHref = '#';\n    this.titleStr = '';\n    this.renderer.addClass(elementRef.nativeElement, 'ant-anchor-link');\n  }\n\n  _createClass(NzAnchorLinkComponent, [{\n    key: \"nzTitle\",\n    set: function set(value) {\n      if (value instanceof TemplateRef) {\n        this.titleStr = null;\n        this.titleTpl = value;\n      } else {\n        this.titleStr = value;\n      }\n    }\n  }, {\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      this.anchorComp.registerLink(this);\n    }\n  }, {\n    key: \"getLinkTitleElement\",\n    value: function getLinkTitleElement() {\n      return this.linkTitle.nativeElement;\n    }\n  }, {\n    key: \"setActive\",\n    value: function setActive() {\n      this.renderer.addClass(this.elementRef.nativeElement, 'ant-anchor-link-active');\n    }\n  }, {\n    key: \"unsetActive\",\n    value: function unsetActive() {\n      this.renderer.removeClass(this.elementRef.nativeElement, 'ant-anchor-link-active');\n    }\n  }, {\n    key: \"goToClick\",\n    value: function goToClick(e) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (this.platform.isBrowser) {\n        this.anchorComp.handleScrollTo(this);\n      }\n    }\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.anchorComp.unregisterLink(this);\n    }\n  }]);\n\n  return NzAnchorLinkComponent;\n}();\n\nNzAnchorLinkComponent.ɵfac = function NzAnchorLinkComponent_Factory(t) {\n  return new (t || NzAnchorLinkComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NzAnchorComponent), i0.ɵɵdirectiveInject(i3.Platform), i0.ɵɵdirectiveInject(i0.Renderer2));\n};\n\nNzAnchorLinkComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: NzAnchorLinkComponent,\n  selectors: [[\"nz-link\"]],\n  contentQueries: function NzAnchorLinkComponent_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      i0.ɵɵcontentQuery(dirIndex, _c3, 5);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nzTemplate = _t.first);\n    }\n  },\n  viewQuery: function NzAnchorLinkComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c4, 5);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.linkTitle = _t.first);\n    }\n  },\n  inputs: {\n    nzHref: \"nzHref\",\n    nzTitle: \"nzTitle\"\n  },\n  exportAs: [\"nzLink\"],\n  ngContentSelectors: _c2,\n  decls: 4,\n  vars: 4,\n  consts: [[1, \"ant-anchor-link-title\", 3, \"href\", \"title\", \"click\"], [\"linkTitle\", \"\"], [4, \"ngIf\", \"ngIfElse\"]],\n  template: function NzAnchorLinkComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵelementStart(0, \"a\", 0, 1);\n      i0.ɵɵlistener(\"click\", function NzAnchorLinkComponent_Template_a_click_0_listener($event) {\n        return ctx.goToClick($event);\n      });\n      i0.ɵɵtemplate(2, NzAnchorLinkComponent_span_2_Template, 2, 1, \"span\", 2);\n      i0.ɵɵelementEnd();\n      i0.ɵɵprojection(3);\n    }\n\n    if (rf & 2) {\n      i0.ɵɵpropertyInterpolate(\"href\", ctx.nzHref, i0.ɵɵsanitizeUrl);\n      i0.ɵɵpropertyInterpolate(\"title\", ctx.titleStr);\n      i0.ɵɵadvance(2);\n      i0.ɵɵproperty(\"ngIf\", ctx.titleStr)(\"ngIfElse\", ctx.titleTpl || ctx.nzTemplate);\n    }\n  },\n  directives: [i5.NgIf],\n  encapsulation: 2,\n  changeDetection: 0\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NzAnchorLinkComponent, [{\n    type: Component,\n    args: [{\n      selector: 'nz-link',\n      exportAs: 'nzLink',\n      preserveWhitespaces: false,\n      template: \"\\n    <a #linkTitle (click)=\\\"goToClick($event)\\\" href=\\\"{{ nzHref }}\\\" class=\\\"ant-anchor-link-title\\\" title=\\\"{{ titleStr }}\\\">\\n      <span *ngIf=\\\"titleStr; else titleTpl || nzTemplate\\\">{{ titleStr }}</span>\\n    </a>\\n    <ng-content></ng-content>\\n  \",\n      encapsulation: ViewEncapsulation.None,\n      changeDetection: ChangeDetectionStrategy.OnPush\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: NzAnchorComponent\n    }, {\n      type: i3.Platform\n    }, {\n      type: i0.Renderer2\n    }];\n  }, {\n    nzHref: [{\n      type: Input\n    }],\n    nzTitle: [{\n      type: Input\n    }],\n    nzTemplate: [{\n      type: ContentChild,\n      args: ['nzTemplate', {\n        static: false\n      }]\n    }],\n    linkTitle: [{\n      type: ViewChild,\n      args: ['linkTitle']\n    }]\n  });\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nvar NzAnchorModule = /*#__PURE__*/_createClass(function NzAnchorModule() {\n  _classCallCheck(this, NzAnchorModule);\n});\n\nNzAnchorModule.ɵfac = function NzAnchorModule_Factory(t) {\n  return new (t || NzAnchorModule)();\n};\n\nNzAnchorModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NzAnchorModule,\n  declarations: [NzAnchorComponent, NzAnchorLinkComponent],\n  imports: [BidiModule, CommonModule, NzAffixModule, PlatformModule],\n  exports: [NzAnchorComponent, NzAnchorLinkComponent]\n});\nNzAnchorModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[BidiModule, CommonModule, NzAffixModule, PlatformModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NzAnchorModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [NzAnchorComponent, NzAnchorLinkComponent],\n      exports: [NzAnchorComponent, NzAnchorLinkComponent],\n      imports: [BidiModule, CommonModule, NzAffixModule, PlatformModule]\n    }]\n  }], null, null);\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NzAnchorComponent, NzAnchorLinkComponent, NzAnchorModule }; //# sourceMappingURL=ng-zorro-antd-anchor.mjs.map","map":null,"metadata":{},"sourceType":"module"}