{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\toConsumableArray.js\";\nimport _classCallCheck from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport { __decorate } from 'tslib';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, Inject, Optional, ViewChild, Input, Output, NgModule } from '@angular/core';\nimport { Subscription, ReplaySubject, Subject, merge, fromEvent } from 'rxjs';\nimport { takeUntil, map, throttleTime } from 'rxjs/operators';\nimport * as i1 from 'ng-zorro-antd/core/config';\nimport { WithConfig } from 'ng-zorro-antd/core/config';\nimport { shallowEqual, getStyleAsText, InputNumber } from 'ng-zorro-antd/core/util';\nimport * as i2 from 'ng-zorro-antd/core/services';\nimport * as i3 from '@angular/cdk/platform';\nimport { PlatformModule } from '@angular/cdk/platform';\nimport * as i4 from 'ng-zorro-antd/cdk/resize-observer';\nimport * as i5 from '@angular/cdk/bidi';\nimport { BidiModule } from '@angular/cdk/bidi';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nvar _c0 = [\"fixedEl\"];\nvar _c1 = [\"*\"];\nvar AffixRespondEvents;\n\n(function (AffixRespondEvents) {\n  AffixRespondEvents[\"resize\"] = \"resize\";\n  AffixRespondEvents[\"scroll\"] = \"scroll\";\n  AffixRespondEvents[\"touchstart\"] = \"touchstart\";\n  AffixRespondEvents[\"touchmove\"] = \"touchmove\";\n  AffixRespondEvents[\"touchend\"] = \"touchend\";\n  AffixRespondEvents[\"pageshow\"] = \"pageshow\";\n  AffixRespondEvents[\"load\"] = \"LOAD\";\n})(AffixRespondEvents || (AffixRespondEvents = {}));\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nfunction isTargetWindow(target) {\n  return typeof window !== 'undefined' && target === window;\n}\n\nfunction getTargetRect(target) {\n  return !isTargetWindow(target) ? target.getBoundingClientRect() : {\n    top: 0,\n    left: 0,\n    bottom: 0\n  };\n}\n\nvar NZ_CONFIG_MODULE_NAME = 'affix';\nvar NZ_AFFIX_CLS_PREFIX = 'ant-affix';\nvar NZ_AFFIX_DEFAULT_SCROLL_TIME = 20;\n\nvar NzAffixComponent = /*#__PURE__*/function () {\n  function NzAffixComponent(el, doc, nzConfigService, scrollSrv, ngZone, platform, renderer, nzResizeObserver, cdr, directionality) {\n    _classCallCheck(this, NzAffixComponent);\n\n    this.nzConfigService = nzConfigService;\n    this.scrollSrv = scrollSrv;\n    this.ngZone = ngZone;\n    this.platform = platform;\n    this.renderer = renderer;\n    this.nzResizeObserver = nzResizeObserver;\n    this.cdr = cdr;\n    this.directionality = directionality;\n    this._nzModuleName = NZ_CONFIG_MODULE_NAME;\n    this.nzChange = new EventEmitter();\n    this.dir = 'ltr';\n    this.positionChangeSubscription = Subscription.EMPTY;\n    this.offsetChanged$ = new ReplaySubject(1);\n    this.destroy$ = new Subject(); // The wrapper would stay at the original position as a placeholder.\n\n    this.placeholderNode = el.nativeElement;\n    this.document = doc;\n  }\n\n  _createClass(NzAffixComponent, [{\n    key: \"target\",\n    get: function get() {\n      var el = this.nzTarget;\n      return (typeof el === 'string' ? this.document.querySelector(el) : el) || window;\n    }\n  }, {\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      var _this = this;\n\n      var _a;\n\n      (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe(function (direction) {\n        _this.dir = direction;\n\n        _this.registerListeners();\n\n        _this.updatePosition({});\n\n        _this.cdr.detectChanges();\n      });\n      this.dir = this.directionality.value;\n    }\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(changes) {\n      var nzOffsetBottom = changes.nzOffsetBottom,\n          nzOffsetTop = changes.nzOffsetTop,\n          nzTarget = changes.nzTarget;\n\n      if (nzOffsetBottom || nzOffsetTop) {\n        this.offsetChanged$.next();\n      }\n\n      if (nzTarget) {\n        this.registerListeners();\n      }\n    }\n  }, {\n    key: \"ngAfterViewInit\",\n    value: function ngAfterViewInit() {\n      this.registerListeners();\n    }\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.removeListeners();\n    }\n  }, {\n    key: \"registerListeners\",\n    value: function registerListeners() {\n      var _this2 = this;\n\n      if (!this.platform.isBrowser) {\n        return;\n      }\n\n      this.removeListeners();\n      var el = this.target === window ? this.document.body : this.target;\n      this.positionChangeSubscription = this.ngZone.runOutsideAngular(function () {\n        return merge.apply(void 0, _toConsumableArray(Object.keys(AffixRespondEvents).map(function (evName) {\n          return fromEvent(_this2.target, evName);\n        })).concat([_this2.offsetChanged$.pipe(map(function () {\n          return {};\n        })), _this2.nzResizeObserver.observe(el)])).pipe(throttleTime(NZ_AFFIX_DEFAULT_SCROLL_TIME, undefined, {\n          trailing: true\n        }), takeUntil(_this2.destroy$)).subscribe(function (e) {\n          return _this2.updatePosition(e);\n        });\n      });\n      this.timeout = setTimeout(function () {\n        return _this2.updatePosition({});\n      });\n    }\n  }, {\n    key: \"removeListeners\",\n    value: function removeListeners() {\n      clearTimeout(this.timeout);\n      this.positionChangeSubscription.unsubscribe();\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n  }, {\n    key: \"getOffset\",\n    value: function getOffset(element, target) {\n      var elemRect = element.getBoundingClientRect();\n      var targetRect = getTargetRect(target);\n      var scrollTop = this.scrollSrv.getScroll(target, true);\n      var scrollLeft = this.scrollSrv.getScroll(target, false);\n      var docElem = this.document.body;\n      var clientTop = docElem.clientTop || 0;\n      var clientLeft = docElem.clientLeft || 0;\n      return {\n        top: elemRect.top - targetRect.top + scrollTop - clientTop,\n        left: elemRect.left - targetRect.left + scrollLeft - clientLeft,\n        width: elemRect.width,\n        height: elemRect.height\n      };\n    }\n  }, {\n    key: \"setAffixStyle\",\n    value: function setAffixStyle(e, affixStyle) {\n      var originalAffixStyle = this.affixStyle;\n      var isWindow = this.target === window;\n\n      if (e.type === 'scroll' && originalAffixStyle && affixStyle && isWindow) {\n        return;\n      }\n\n      if (shallowEqual(originalAffixStyle, affixStyle)) {\n        return;\n      }\n\n      var fixed = !!affixStyle;\n      var wrapEl = this.fixedEl.nativeElement;\n      this.renderer.setStyle(wrapEl, 'cssText', getStyleAsText(affixStyle));\n      this.affixStyle = affixStyle;\n\n      if (fixed) {\n        wrapEl.classList.add(NZ_AFFIX_CLS_PREFIX);\n      } else {\n        wrapEl.classList.remove(NZ_AFFIX_CLS_PREFIX);\n      }\n\n      this.updateRtlClass();\n\n      if (affixStyle && !originalAffixStyle || !affixStyle && originalAffixStyle) {\n        this.nzChange.emit(fixed);\n      }\n    }\n  }, {\n    key: \"setPlaceholderStyle\",\n    value: function setPlaceholderStyle(placeholderStyle) {\n      var originalPlaceholderStyle = this.placeholderStyle;\n\n      if (shallowEqual(placeholderStyle, originalPlaceholderStyle)) {\n        return;\n      }\n\n      this.renderer.setStyle(this.placeholderNode, 'cssText', getStyleAsText(placeholderStyle));\n      this.placeholderStyle = placeholderStyle;\n    }\n  }, {\n    key: \"syncPlaceholderStyle\",\n    value: function syncPlaceholderStyle(e) {\n      if (!this.affixStyle) {\n        return;\n      }\n\n      this.renderer.setStyle(this.placeholderNode, 'cssText', '');\n      this.placeholderStyle = undefined;\n      var styleObj = {\n        width: this.placeholderNode.offsetWidth,\n        height: this.fixedEl.nativeElement.offsetHeight\n      };\n      this.setAffixStyle(e, Object.assign(Object.assign({}, this.affixStyle), styleObj));\n      this.setPlaceholderStyle(styleObj);\n    }\n  }, {\n    key: \"updatePosition\",\n    value: function updatePosition(e) {\n      if (!this.platform.isBrowser) {\n        return;\n      }\n\n      var targetNode = this.target;\n      var offsetTop = this.nzOffsetTop;\n      var scrollTop = this.scrollSrv.getScroll(targetNode, true);\n      var elemOffset = this.getOffset(this.placeholderNode, targetNode);\n      var fixedNode = this.fixedEl.nativeElement;\n      var elemSize = {\n        width: fixedNode.offsetWidth,\n        height: fixedNode.offsetHeight\n      };\n      var offsetMode = {\n        top: false,\n        bottom: false\n      }; // Default to `offsetTop=0`.\n\n      if (typeof offsetTop !== 'number' && typeof this.nzOffsetBottom !== 'number') {\n        offsetMode.top = true;\n        offsetTop = 0;\n      } else {\n        offsetMode.top = typeof offsetTop === 'number';\n        offsetMode.bottom = typeof this.nzOffsetBottom === 'number';\n      }\n\n      var targetRect = getTargetRect(targetNode);\n      var targetInnerHeight = targetNode.innerHeight || targetNode.clientHeight;\n\n      if (scrollTop >= elemOffset.top - offsetTop && offsetMode.top) {\n        var width = elemOffset.width;\n        var top = targetRect.top + offsetTop;\n        this.setAffixStyle(e, {\n          position: 'fixed',\n          top: top,\n          left: targetRect.left + elemOffset.left,\n          width: width\n        });\n        this.setPlaceholderStyle({\n          width: width,\n          height: elemSize.height\n        });\n      } else if (scrollTop <= elemOffset.top + elemSize.height + this.nzOffsetBottom - targetInnerHeight && offsetMode.bottom) {\n        var targetBottomOffset = targetNode === window ? 0 : window.innerHeight - targetRect.bottom;\n        var _width = elemOffset.width;\n        this.setAffixStyle(e, {\n          position: 'fixed',\n          bottom: targetBottomOffset + this.nzOffsetBottom,\n          left: targetRect.left + elemOffset.left,\n          width: _width\n        });\n        this.setPlaceholderStyle({\n          width: _width,\n          height: elemOffset.height\n        });\n      } else {\n        if (e.type === AffixRespondEvents.resize && this.affixStyle && this.affixStyle.position === 'fixed' && this.placeholderNode.offsetWidth) {\n          this.setAffixStyle(e, Object.assign(Object.assign({}, this.affixStyle), {\n            width: this.placeholderNode.offsetWidth\n          }));\n        } else {\n          this.setAffixStyle(e);\n        }\n\n        this.setPlaceholderStyle();\n      }\n\n      if (e.type === 'resize') {\n        this.syncPlaceholderStyle(e);\n      }\n    }\n  }, {\n    key: \"updateRtlClass\",\n    value: function updateRtlClass() {\n      var wrapEl = this.fixedEl.nativeElement;\n\n      if (this.dir === 'rtl') {\n        if (wrapEl.classList.contains(NZ_AFFIX_CLS_PREFIX)) {\n          wrapEl.classList.add(\"\".concat(NZ_AFFIX_CLS_PREFIX, \"-rtl\"));\n        } else {\n          wrapEl.classList.remove(\"\".concat(NZ_AFFIX_CLS_PREFIX, \"-rtl\"));\n        }\n      } else {\n        wrapEl.classList.remove(\"\".concat(NZ_AFFIX_CLS_PREFIX, \"-rtl\"));\n      }\n    }\n  }]);\n\n  return NzAffixComponent;\n}();\n\nNzAffixComponent.ɵfac = function NzAffixComponent_Factory(t) {\n  return new (t || NzAffixComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i1.NzConfigService), i0.ɵɵdirectiveInject(i2.NzScrollService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3.Platform), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i4.NzResizeObserver), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i5.Directionality, 8));\n};\n\nNzAffixComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: NzAffixComponent,\n  selectors: [[\"nz-affix\"]],\n  viewQuery: function NzAffixComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c0, 7);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fixedEl = _t.first);\n    }\n  },\n  inputs: {\n    nzTarget: \"nzTarget\",\n    nzOffsetTop: \"nzOffsetTop\",\n    nzOffsetBottom: \"nzOffsetBottom\"\n  },\n  outputs: {\n    nzChange: \"nzChange\"\n  },\n  exportAs: [\"nzAffix\"],\n  features: [i0.ɵɵNgOnChangesFeature],\n  ngContentSelectors: _c1,\n  decls: 3,\n  vars: 0,\n  consts: [[\"fixedEl\", \"\"]],\n  template: function NzAffixComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵelementStart(0, \"div\", null, 0);\n      i0.ɵɵprojection(2);\n      i0.ɵɵelementEnd();\n    }\n  },\n  encapsulation: 2,\n  changeDetection: 0\n});\n\n__decorate([WithConfig(), InputNumber(undefined)], NzAffixComponent.prototype, \"nzOffsetTop\", void 0);\n\n__decorate([WithConfig(), InputNumber(undefined)], NzAffixComponent.prototype, \"nzOffsetBottom\", void 0);\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NzAffixComponent, [{\n    type: Component,\n    args: [{\n      selector: 'nz-affix',\n      exportAs: 'nzAffix',\n      template: \"\\n    <div #fixedEl>\\n      <ng-content></ng-content>\\n    </div>\\n  \",\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      encapsulation: ViewEncapsulation.None\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: i1.NzConfigService\n    }, {\n      type: i2.NzScrollService\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i3.Platform\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: i4.NzResizeObserver\n    }, {\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i5.Directionality,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, {\n    fixedEl: [{\n      type: ViewChild,\n      args: ['fixedEl', {\n        static: true\n      }]\n    }],\n    nzTarget: [{\n      type: Input\n    }],\n    nzOffsetTop: [{\n      type: Input\n    }],\n    nzOffsetBottom: [{\n      type: Input\n    }],\n    nzChange: [{\n      type: Output\n    }]\n  });\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nvar NzAffixModule = /*#__PURE__*/_createClass(function NzAffixModule() {\n  _classCallCheck(this, NzAffixModule);\n});\n\nNzAffixModule.ɵfac = function NzAffixModule_Factory(t) {\n  return new (t || NzAffixModule)();\n};\n\nNzAffixModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NzAffixModule,\n  declarations: [NzAffixComponent],\n  imports: [BidiModule, CommonModule, PlatformModule],\n  exports: [NzAffixComponent]\n});\nNzAffixModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[BidiModule, CommonModule, PlatformModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NzAffixModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [NzAffixComponent],\n      exports: [NzAffixComponent],\n      imports: [BidiModule, CommonModule, PlatformModule]\n    }]\n  }], null, null);\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NzAffixComponent, NzAffixModule }; //# sourceMappingURL=ng-zorro-antd-affix.mjs.map","map":null,"metadata":{},"sourceType":"module"}