{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\defineProperty.js\";\nimport _inherits from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\inherits.js\";\nimport _createSuper from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createSuper.js\";\nimport _toArray from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\toArray.js\";\nimport _classCallCheck from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:\\\\Users\\\\admin\\\\Documents\\\\work\\\\ESAPP\\\\esapp-mobile\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\toConsumableArray.js\";\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { TemplateRef, Injectable, InjectionToken, NgModule, ANALYZE_FOR_ENTRY_COMPONENTS, Inject, Optional, Component, Input, ChangeDetectionStrategy, EventEmitter, Output, Attribute, ViewChild, ElementRef, NgZone, ViewContainerRef, ComponentFactoryResolver, Renderer2, Injector, ChangeDetectorRef, Directive, defineInjectable, inject, INJECTOR } from '@angular/core';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { __rest } from 'tslib';\nimport { debounceTime, switchMap, distinctUntilChanged, take, startWith, filter, map } from 'rxjs/operators';\nimport { AbstractControl, FormArray, FormGroup, FormControl, FormGroupDirective, Validators } from '@angular/forms';\nimport { isObservable, Subject, of, merge, Observable } from 'rxjs';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} form\n * @param {?} callback\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/forms';\nimport * as ɵngcc2 from '@angular/common';\nimport * as ɵngcc3 from '@angular/platform-browser';\nvar _c0 = [\"content\"];\n\nfunction FormlyForm_formly_field_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"formly-field\", 2);\n  }\n\n  if (rf & 2) {\n    var field_r2 = ctx.$implicit;\n    ɵngcc0.ɵɵproperty(\"form\", field_r2.form)(\"options\", field_r2.options)(\"model\", field_r2.model)(\"field\", field_r2);\n  }\n}\n\nvar _c1 = [\"*\"];\nvar _c2 = [\"container\"];\n\nfunction FormlyField_ng_template_0_Template(rf, ctx) {}\n\nvar _c3 = [\"fieldComponent\"];\n\nfunction FormlyGroup_formly_field_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"formly-field\", 1);\n  }\n\n  if (rf & 2) {\n    var f_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵproperty(\"field\", f_r1);\n  }\n}\n\nfunction disableTreeValidityCall(form, callback) {\n  /** @type {?} */\n  var _updateTreeValidity = form._updateTreeValidity.bind(form);\n\n  form._updateTreeValidity =\n  /**\n  * @return {?}\n  */\n  function () {};\n\n  callback();\n  form._updateTreeValidity = _updateTreeValidity;\n}\n/**\n * @param {?} formId\n * @param {?} field\n * @param {?} index\n * @return {?}\n */\n\n\nfunction getFieldId(formId, field, index) {\n  if (field.id) return field.id;\n  /** @type {?} */\n\n  var type = field.type;\n\n  if (!type && field.template) {\n    type = 'template';\n  }\n\n  if (isFunction(type)) {\n    type =\n    /** @type {?} */\n    type.prototype.constructor.name;\n  }\n\n  return [formId, type, field.key, index].join('_');\n}\n/**\n * @param {?} field\n * @return {?}\n */\n\n\nfunction getKeyPath(field) {\n  if (!field.key) {\n    return [];\n  }\n  /* We store the keyPath in the field for performance reasons. This function will be called frequently. */\n\n\n  if (!field._keyPath || field._keyPath.key !== field.key) {\n    /** @type {?} */\n    var path = [];\n\n    if (typeof field.key === 'string') {\n      /** @type {?} */\n      var key = field.key.indexOf('[') === -1 ? field.key : field.key.replace(/\\[(\\w+)\\]/g, '.$1');\n      path = key.indexOf('.') !== -1 ? key.split('.') : [key];\n    } else if (Array.isArray(field.key)) {\n      path = field.key.slice(0);\n    } else {\n      path = [\"\".concat(field.key)];\n    }\n\n    field._keyPath = {\n      key: field.key,\n      path: path\n    };\n  }\n\n  return field._keyPath.path.slice(0);\n}\n/** @type {?} */\n\n\nvar FORMLY_VALIDATORS = ['required', 'pattern', 'minLength', 'maxLength', 'min', 'max'];\n/**\n * @param {?} field\n * @param {?} value\n * @return {?}\n */\n\nfunction assignFieldValue(field, value) {\n  /** @type {?} */\n  var paths = getKeyPath(field);\n\n  if (paths.length === 0) {\n    return;\n  }\n  /** @type {?} */\n\n\n  var root = field;\n\n  while (root.parent) {\n    root = root.parent;\n    paths = [].concat(_toConsumableArray(getKeyPath(root)), _toConsumableArray(paths));\n  }\n\n  if (value === undefined && field.resetOnHide) {\n    /** @type {?} */\n    var k = paths.pop();\n    /** @type {?} */\n\n    var m = paths.reduce(\n    /**\n    * @param {?} model\n    * @param {?} path\n    * @return {?}\n    */\n    function (model, path) {\n      return model[path] || {};\n    }, root.model);\n    delete m[k];\n    return;\n  }\n\n  assignModelValue(root.model, paths, value);\n}\n/**\n * @param {?} model\n * @param {?} paths\n * @param {?} value\n * @return {?}\n */\n\n\nfunction assignModelValue(model, paths, value) {\n  for (var i = 0; i < paths.length - 1; i++) {\n    /** @type {?} */\n    var path = paths[i];\n\n    if (!model[path] || !isObject(model[path])) {\n      model[path] = /^\\d+$/.test(paths[i + 1]) ? [] : {};\n    }\n\n    model = model[path];\n  }\n\n  model[paths[paths.length - 1]] = clone(value);\n}\n/**\n * @param {?} field\n * @return {?}\n */\n\n\nfunction getFieldValue(field) {\n  /** @type {?} */\n  var model = field.parent.model;\n\n  var _iterator = _createForOfIteratorHelper(getKeyPath(field)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var path = _step.value;\n\n      if (!model) {\n        return model;\n      }\n\n      model = model[path];\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return model;\n}\n/**\n * @param {?} dest\n * @param {...?} args\n * @return {?}\n */\n\n\nfunction reverseDeepMerge(dest) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  args.forEach(\n  /**\n  * @param {?} src\n  * @return {?}\n  */\n  function (src) {\n    for (var srcArg in src) {\n      if (isNullOrUndefined(dest[srcArg]) || isBlankString(dest[srcArg])) {\n        dest[srcArg] = clone(src[srcArg]);\n      } else if (objAndSameType(dest[srcArg], src[srcArg])) {\n        reverseDeepMerge(dest[srcArg], src[srcArg]);\n      }\n    }\n  });\n  return dest;\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction isNullOrUndefined(value) {\n  return value === undefined || value === null;\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction isUndefined(value) {\n  return value === undefined;\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction isBlankString(value) {\n  return value === '';\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n * @param {?} obj1\n * @param {?} obj2\n * @return {?}\n */\n\n\nfunction objAndSameType(obj1, obj2) {\n  return isObject(obj1) && isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2) && !(Array.isArray(obj1) || Array.isArray(obj2));\n}\n/**\n * @param {?} x\n * @return {?}\n */\n\n\nfunction isObject(x) {\n  return x != null && typeof x === 'object';\n}\n/**\n * @param {?} obj\n * @return {?}\n */\n\n\nfunction isPromise(obj) {\n  return !!obj && typeof obj.then === 'function';\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction clone(value) {\n  if (!isObject(value) || isObservable(value) || value instanceof TemplateRef ||\n  /* instanceof SafeHtmlImpl */\n  value.changingThisBreaksApplicationSecurity || ['RegExp', 'FileList', 'File', 'Blob'].indexOf(value.constructor.name) !== -1) {\n    return value;\n  }\n\n  if (value instanceof Set) {\n    return new Set(value);\n  }\n\n  if (value instanceof Map) {\n    return new Map(value);\n  } // https://github.com/moment/moment/blob/master/moment.js#L252\n\n\n  if (value._isAMomentObject && isFunction(value.clone)) {\n    return value.clone();\n  }\n\n  if (value instanceof AbstractControl) {\n    return null;\n  }\n\n  if (value instanceof Date) {\n    return new Date(value.getTime());\n  }\n\n  if (Array.isArray(value)) {\n    return value.slice(0).map(\n    /**\n    * @param {?} v\n    * @return {?}\n    */\n    function (v) {\n      return clone(v);\n    });\n  } // best way to clone a js object maybe\n  // https://stackoverflow.com/questions/41474986/how-to-clone-a-javascript-es6-class-instance\n\n  /** @type {?} */\n\n\n  var proto = Object.getPrototypeOf(value);\n  /** @type {?} */\n\n  var c = Object.create(proto);\n  c = Object.setPrototypeOf(c, proto); // need to make a deep copy so we dont use Object.assign\n  // also Object.assign wont copy property descriptor exactly\n\n  return Object.keys(value).reduce(\n  /**\n  * @param {?} newVal\n  * @param {?} prop\n  * @return {?}\n  */\n  function (newVal, prop) {\n    /** @type {?} */\n    var propDesc = Object.getOwnPropertyDescriptor(value, prop);\n\n    if (propDesc.get) {\n      Object.defineProperty(newVal, prop, propDesc);\n    } else {\n      newVal[prop] = clone(value[prop]);\n    }\n\n    return newVal;\n  }, c);\n}\n/**\n * @param {?} field\n * @param {?} prop\n * @param {?} defaultValue\n * @return {?}\n */\n\n\nfunction defineHiddenProp(field, prop, defaultValue) {\n  Object.defineProperty(field, prop, {\n    enumerable: false,\n    writable: true,\n    configurable: true\n  });\n  field[prop] = defaultValue;\n}\n/**\n * @template T\n * @param {?} o\n * @param {?} prop\n * @param {?} setFn\n * @return {?}\n */\n\n\nfunction wrapProperty(o, prop, setFn) {\n  if (!o._observers) {\n    defineHiddenProp(o, '_observers', {});\n  }\n\n  if (!o._observers[prop]) {\n    o._observers[prop] = [];\n  }\n  /** @type {?} */\n\n\n  var fns = o._observers[prop];\n\n  if (fns.indexOf(setFn) === -1) {\n    fns.push(setFn);\n    setFn({\n      currentValue: o[prop],\n      firstChange: true\n    });\n\n    if (fns.length === 1) {\n      defineHiddenProp(o, \"___$\".concat(prop), o[prop]);\n      Object.defineProperty(o, prop, {\n        configurable: true,\n        get:\n        /**\n        * @return {?}\n        */\n        function get() {\n          return o[\"___$\".concat(prop)];\n        },\n        set:\n        /**\n        * @param {?} currentValue\n        * @return {?}\n        */\n        function set(currentValue) {\n          if (currentValue !== o[\"___$\".concat(prop)]) {\n            /** @type {?} */\n            var previousValue = o[\"___$\".concat(prop)];\n            o[\"___$\".concat(prop)] = currentValue;\n            fns.forEach(\n            /**\n            * @param {?} changeFn\n            * @return {?}\n            */\n            function (changeFn) {\n              return changeFn({\n                previousValue: previousValue,\n                currentValue: currentValue,\n                firstChange: false\n              });\n            });\n          }\n        }\n      });\n    }\n  }\n\n  return (\n    /**\n    * @return {?}\n    */\n    function () {\n      return fns.splice(fns.indexOf(setFn), 1);\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar FORMLY_CONFIG = new InjectionToken('FORMLY_CONFIG');\n/**\n * Maintains list of formly field directive types. This can be used to register new field templates.\n */\n\nvar FormlyConfig = /*#__PURE__*/function () {\n  function FormlyConfig() {\n    _classCallCheck(this, FormlyConfig);\n\n    this.types = {};\n    this.validators = {};\n    this.wrappers = {};\n    this.messages = {};\n    this.templateManipulators = {\n      preWrapper: [],\n      postWrapper: []\n    };\n    this.extras = {\n      checkExpressionOn: 'changeDetectionCheck',\n      lazyRender: false,\n      showError:\n      /**\n      * @param {?} field\n      * @return {?}\n      */\n      function showError(field) {\n        return field.formControl && field.formControl.invalid && (field.formControl.touched || field.options.parentForm && field.options.parentForm.submitted || !!(field.field.validation && field.field.validation.show));\n      }\n    };\n    this.extensions = {};\n  }\n  /**\n   * @param {?} config\n   * @return {?}\n   */\n\n\n  _createClass(FormlyConfig, [{\n    key: \"addConfig\",\n    value: function addConfig(config) {\n      var _this = this;\n\n      if (config.types) {\n        config.types.forEach(\n        /**\n        * @param {?} type\n        * @return {?}\n        */\n        function (type) {\n          return _this.setType(type);\n        });\n      }\n\n      if (config.validators) {\n        config.validators.forEach(\n        /**\n        * @param {?} validator\n        * @return {?}\n        */\n        function (validator) {\n          return _this.setValidator(validator);\n        });\n      }\n\n      if (config.wrappers) {\n        config.wrappers.forEach(\n        /**\n        * @param {?} wrapper\n        * @return {?}\n        */\n        function (wrapper) {\n          return _this.setWrapper(wrapper);\n        });\n      }\n\n      if (config.manipulators) {\n        console.warn(\"NgxFormly: passing 'manipulators' config is deprecated, use custom extension instead.\");\n        config.manipulators.forEach(\n        /**\n        * @param {?} manipulator\n        * @return {?}\n        */\n        function (manipulator) {\n          return _this.setManipulator(manipulator);\n        });\n      }\n\n      if (config.validationMessages) {\n        config.validationMessages.forEach(\n        /**\n        * @param {?} validation\n        * @return {?}\n        */\n        function (validation) {\n          return _this.addValidatorMessage(validation.name, validation.message);\n        });\n      }\n\n      if (config.extensions) {\n        config.extensions.forEach(\n        /**\n        * @param {?} c\n        * @return {?}\n        */\n        function (c) {\n          return _this.extensions[c.name] = c.extension;\n        });\n      }\n\n      if (config.extras) {\n        this.extras = Object.assign({}, this.extras, config.extras);\n      }\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"setType\",\n    value: function setType(options) {\n      var _this2 = this;\n\n      if (Array.isArray(options)) {\n        options.forEach(\n        /**\n        * @param {?} option\n        * @return {?}\n        */\n        function (option) {\n          return _this2.setType(option);\n        });\n      } else {\n        if (!this.types[options.name]) {\n          this.types[options.name] =\n          /** @type {?} */\n          {\n            name: options.name\n          };\n        }\n\n        ['component', 'extends', 'defaultOptions', 'wrappers'].forEach(\n        /**\n        * @param {?} prop\n        * @return {?}\n        */\n        function (prop) {\n          if (options.hasOwnProperty(prop)) {\n            _this2.types[options.name][prop] = options[prop];\n          }\n        });\n      }\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n\n  }, {\n    key: \"getType\",\n    value: function getType(name) {\n      if (!this.types[name]) {\n        throw new Error(\"[Formly Error] The type \\\"\".concat(name, \"\\\" could not be found. Please make sure that is registered through the FormlyModule declaration.\"));\n      }\n\n      this.mergeExtendedType(name);\n      return this.types[name];\n    }\n    /**\n     * @param {?=} field\n     * @return {?}\n     */\n\n  }, {\n    key: \"getMergedField\",\n    value: function getMergedField() {\n      var _this3 = this;\n\n      var field = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      /** @type {?} */\n      var type = this.getType(field.type);\n\n      if (type.defaultOptions) {\n        reverseDeepMerge(field, type.defaultOptions);\n      }\n      /** @type {?} */\n\n\n      var extendDefaults = type.extends && this.getType(type.extends).defaultOptions;\n\n      if (extendDefaults) {\n        reverseDeepMerge(field, extendDefaults);\n      }\n\n      if (field && field.optionsTypes) {\n        field.optionsTypes.forEach(\n        /**\n        * @param {?} option\n        * @return {?}\n        */\n        function (option) {\n          /** @type {?} */\n          var defaultOptions = _this3.getType(option).defaultOptions;\n\n          if (defaultOptions) {\n            reverseDeepMerge(field, defaultOptions);\n          }\n        });\n      }\n      /** @type {?} */\n\n\n      var componentRef = this.resolveFieldTypeRef(field);\n\n      if (componentRef && componentRef.instance && componentRef.instance.defaultOptions) {\n        reverseDeepMerge(field, componentRef.instance.defaultOptions);\n      }\n\n      if (!field.wrappers && type.wrappers) {\n        field.wrappers = _toConsumableArray(type.wrappers);\n      }\n    }\n    /**\n     * \\@internal\n     * @param {?=} field\n     * @return {?}\n     */\n\n  }, {\n    key: \"resolveFieldTypeRef\",\n    value: function resolveFieldTypeRef() {\n      var field = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!field.type) {\n        return null;\n      }\n      /** @type {?} */\n\n\n      var type = this.getType(field.type);\n\n      if (!type.component || type['_componentRef']) {\n        return type['_componentRef'];\n      }\n\n      var _field$parent$options = field.parent.options,\n          _resolver = _field$parent$options._resolver,\n          _injector = _field$parent$options._injector;\n      /** @type {?} */\n\n      var componentRef = _resolver.resolveComponentFactory(type.component).create(_injector);\n\n      defineHiddenProp(type, '_componentRef', componentRef);\n      componentRef.destroy();\n      return type['_componentRef'];\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"setWrapper\",\n    value: function setWrapper(options) {\n      var _this4 = this;\n\n      this.wrappers[options.name] = options;\n\n      if (options.types) {\n        options.types.forEach(\n        /**\n        * @param {?} type\n        * @return {?}\n        */\n        function (type) {\n          _this4.setTypeWrapper(type, options.name);\n        });\n      }\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n\n  }, {\n    key: \"getWrapper\",\n    value: function getWrapper(name) {\n      if (!this.wrappers[name]) {\n        throw new Error(\"[Formly Error] The wrapper \\\"\".concat(name, \"\\\" could not be found. Please make sure that is registered through the FormlyModule declaration.\"));\n      }\n\n      return this.wrappers[name];\n    }\n    /**\n     * @param {?} type\n     * @param {?} name\n     * @return {?}\n     */\n\n  }, {\n    key: \"setTypeWrapper\",\n    value: function setTypeWrapper(type, name) {\n      if (!this.types[type]) {\n        this.types[type] =\n        /** @type {?} */\n        {};\n      }\n\n      if (!this.types[type].wrappers) {\n        this.types[type].wrappers = [];\n      }\n\n      if (this.types[type].wrappers.indexOf(name) === -1) {\n        this.types[type].wrappers.push(name);\n      }\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"setValidator\",\n    value: function setValidator(options) {\n      this.validators[options.name] = options;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n\n  }, {\n    key: \"getValidator\",\n    value: function getValidator(name) {\n      if (!this.validators[name]) {\n        throw new Error(\"[Formly Error] The validator \\\"\".concat(name, \"\\\" could not be found. Please make sure that is registered through the FormlyModule declaration.\"));\n      }\n\n      return this.validators[name];\n    }\n    /**\n     * @param {?} name\n     * @param {?} message\n     * @return {?}\n     */\n\n  }, {\n    key: \"addValidatorMessage\",\n    value: function addValidatorMessage(name, message) {\n      this.messages[name] = message;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n\n  }, {\n    key: \"getValidatorMessage\",\n    value: function getValidatorMessage(name) {\n      return this.messages[name];\n    }\n    /**\n     * @param {?} manipulator\n     * @return {?}\n     */\n\n  }, {\n    key: \"setManipulator\",\n    value: function setManipulator(manipulator) {\n      new manipulator.class()[manipulator.method](this);\n    }\n    /**\n     * @private\n     * @param {?} name\n     * @return {?}\n     */\n\n  }, {\n    key: \"mergeExtendedType\",\n    value: function mergeExtendedType(name) {\n      if (!this.types[name].extends) {\n        return;\n      }\n      /** @type {?} */\n\n\n      var extendedType = this.getType(this.types[name].extends);\n\n      if (!this.types[name].component) {\n        this.types[name].component = extendedType.component;\n      }\n\n      if (!this.types[name].wrappers) {\n        this.types[name].wrappers = extendedType.wrappers;\n      }\n    }\n  }]);\n\n  return FormlyConfig;\n}();\n\nFormlyConfig.ɵfac = function FormlyConfig_Factory(t) {\n  return new (t || FormlyConfig)();\n};\n\nFormlyConfig.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: FormlyConfig,\n  factory: FormlyConfig.ɵfac,\n  providedIn: 'root'\n});\n/** @nocollapse */\n\nFormlyConfig.ngInjectableDef = defineInjectable({\n  factory: function FormlyConfig_Factory() {\n    return new FormlyConfig();\n  },\n  token: FormlyConfig,\n  providedIn: \"root\"\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormlyConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar FormlyFormBuilder = /*#__PURE__*/function () {\n  /**\n   * @param {?} formlyConfig\n   * @param {?} componentFactoryResolver\n   * @param {?} injector\n   */\n  function FormlyFormBuilder(formlyConfig, componentFactoryResolver, injector) {\n    _classCallCheck(this, FormlyFormBuilder);\n\n    this.formlyConfig = formlyConfig;\n    this.componentFactoryResolver = componentFactoryResolver;\n    this.injector = injector;\n  }\n  /**\n   * @param {?} formControl\n   * @param {?=} fieldGroup\n   * @param {?=} model\n   * @param {?=} options\n   * @return {?}\n   */\n\n\n  _createClass(FormlyFormBuilder, [{\n    key: \"buildForm\",\n    value: function buildForm(formControl) {\n      var _this5 = this;\n\n      var fieldGroup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var model = arguments.length > 2 ? arguments[2] : undefined;\n      var options = arguments.length > 3 ? arguments[3] : undefined;\n\n      if (!this.formlyConfig.extensions.core) {\n        throw new Error('NgxFormly: missing `forRoot()` call. use `forRoot()` when registering the `FormlyModule`.');\n      }\n      /** @type {?} */\n\n\n      var field = {\n        fieldGroup: fieldGroup,\n        model: model,\n        formControl: formControl,\n        options: this._setOptions(options)\n      };\n      disableTreeValidityCall(formControl,\n      /**\n      * @return {?}\n      */\n      function () {\n        return _this5._buildForm(field);\n      });\n\n      field.options._checkField(field, true);\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @return {?}\n     */\n\n  }, {\n    key: \"_buildForm\",\n    value: function _buildForm(field) {\n      var _this6 = this;\n\n      this.getExtensions().forEach(\n      /**\n      * @param {?} extension\n      * @return {?}\n      */\n      function (extension) {\n        return extension.prePopulate && extension.prePopulate(field);\n      });\n      this.getExtensions().forEach(\n      /**\n      * @param {?} extension\n      * @return {?}\n      */\n      function (extension) {\n        return extension.onPopulate && extension.onPopulate(field);\n      });\n\n      if (field.fieldGroup) {\n        field.fieldGroup.forEach(\n        /**\n        * @param {?} f\n        * @return {?}\n        */\n        function (f) {\n          return _this6._buildForm(f);\n        });\n      }\n\n      this.getExtensions().forEach(\n      /**\n      * @param {?} extension\n      * @return {?}\n      */\n      function (extension) {\n        return extension.postPopulate && extension.postPopulate(field);\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"getExtensions\",\n    value: function getExtensions() {\n      var _this7 = this;\n\n      return Object.keys(this.formlyConfig.extensions).map(\n      /**\n      * @param {?} name\n      * @return {?}\n      */\n      function (name) {\n        return _this7.formlyConfig.extensions[name];\n      });\n    }\n    /**\n     * @private\n     * @param {?} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"_setOptions\",\n    value: function _setOptions(options) {\n      var _this8 = this;\n\n      options = options || {};\n      options.formState = options.formState || {};\n\n      if (!options.showError) {\n        options.showError = this.formlyConfig.extras.showError;\n      }\n\n      if (!options.fieldChanges) {\n        defineHiddenProp(options, 'fieldChanges', new Subject());\n      }\n\n      if (!options._resolver) {\n        defineHiddenProp(options, '_resolver', this.componentFactoryResolver);\n      }\n\n      if (!options._injector) {\n        defineHiddenProp(options, '_injector', this.injector);\n      }\n\n      if (!options._hiddenFieldsForCheck) {\n        options._hiddenFieldsForCheck = [];\n      }\n\n      if (!options._markForCheck) {\n        options._markForCheck =\n        /**\n        * @param {?} field\n        * @return {?}\n        */\n        function (field) {\n          if (field._componentRefs) {\n            field._componentRefs.forEach(\n            /**\n            * @param {?} ref\n            * @return {?}\n            */\n            function (ref) {\n              // NOTE: we cannot use ref.changeDetectorRef, see https://github.com/ngx-formly/ngx-formly/issues/2191\n\n              /** @type {?} */\n              var changeDetectorRef = ref.injector.get(ChangeDetectorRef);\n              changeDetectorRef.markForCheck();\n            });\n          }\n\n          if (field.fieldGroup) {\n            field.fieldGroup.forEach(\n            /**\n            * @param {?} f\n            * @return {?}\n            */\n            function (f) {\n              return options._markForCheck(f);\n            });\n          }\n        };\n      }\n\n      if (!options._buildField) {\n        options._buildField =\n        /**\n        * @param {?} field\n        * @return {?}\n        */\n        function (field) {\n          _this8.buildForm(field.form, field.fieldGroup, field.model, field.options);\n\n          return field;\n        };\n      }\n\n      return options;\n    }\n  }]);\n\n  return FormlyFormBuilder;\n}();\n\nFormlyFormBuilder.ɵfac = function FormlyFormBuilder_Factory(t) {\n  return new (t || FormlyFormBuilder)(ɵngcc0.ɵɵinject(FormlyConfig), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n};\n\nFormlyFormBuilder.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: FormlyFormBuilder,\n  factory: FormlyFormBuilder.ɵfac,\n  providedIn: 'root'\n});\n/** @nocollapse */\n\nFormlyFormBuilder.ctorParameters = function () {\n  return [{\n    type: FormlyConfig\n  }, {\n    type: ComponentFactoryResolver\n  }, {\n    type: Injector\n  }];\n};\n/** @nocollapse */\n\n\nFormlyFormBuilder.ngInjectableDef = defineInjectable({\n  factory: function FormlyFormBuilder_Factory() {\n    return new FormlyFormBuilder(inject(FormlyConfig), inject(ComponentFactoryResolver), inject(INJECTOR));\n  },\n  token: FormlyFormBuilder,\n  providedIn: \"root\"\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormlyFormBuilder, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: FormlyConfig\n    }, {\n      type: ɵngcc0.ComponentFactoryResolver\n    }, {\n      type: ɵngcc0.Injector\n    }];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} field\n * @param {?=} emitEvent\n * @return {?}\n */\n\n\nfunction unregisterControl(field) {\n  var emitEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  /** @type {?} */\n  var control = field.formControl;\n  /** @type {?} */\n\n  var fieldIndex = control['_fields'] ? control['_fields'].indexOf(field) : -1;\n\n  if (fieldIndex !== -1) {\n    control['_fields'].splice(fieldIndex, 1);\n  }\n  /** @type {?} */\n\n\n  var form =\n  /** @type {?} */\n  control.parent;\n\n  if (!form) {\n    return;\n  }\n  /** @type {?} */\n\n\n  var opts = {\n    emitEvent: emitEvent\n  };\n\n  if (form instanceof FormArray) {\n    /** @type {?} */\n    var key = form.controls.findIndex(\n    /**\n    * @param {?} c\n    * @return {?}\n    */\n    function (c) {\n      return c === control;\n    });\n\n    if (key !== -1) {\n      updateControl(form, opts,\n      /**\n      * @return {?}\n      */\n      function () {\n        return form.removeAt(key);\n      });\n    }\n  } else if (form instanceof FormGroup) {\n    /** @type {?} */\n    var paths = getKeyPath(field);\n    /** @type {?} */\n\n    var _key2 = paths[paths.length - 1];\n\n    if (form.get([_key2]) === control) {\n      updateControl(form, opts,\n      /**\n      * @return {?}\n      */\n      function () {\n        return form.removeControl(_key2);\n      });\n    }\n  }\n\n  control.setParent(null);\n}\n/**\n * @param {?} field\n * @return {?}\n */\n\n\nfunction findControl(field) {\n  if (field.formControl) {\n    return field.formControl;\n  }\n\n  if (field['shareFormControl'] === false) {\n    return null;\n  }\n  /** @type {?} */\n\n\n  var form =\n  /** @type {?} */\n  field.parent.formControl;\n  return form ? form.get(getKeyPath(field)) : null;\n}\n/**\n * @param {?} field\n * @param {?=} control\n * @param {?=} emitEvent\n * @return {?}\n */\n\n\nfunction registerControl(field, control) {\n  var emitEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  control = control || field.formControl;\n\n  if (!control['_fields']) {\n    defineHiddenProp(control, '_fields', []);\n  }\n\n  if (control['_fields'].indexOf(field) === -1) {\n    control['_fields'].push(field);\n  }\n\n  if (!field.formControl && control) {\n    defineHiddenProp(field, 'formControl', control);\n    control.setValidators(null);\n    control.setAsyncValidators(null);\n    field.templateOptions.disabled = !!field.templateOptions.disabled;\n    wrapProperty(field.templateOptions, 'disabled',\n    /**\n    * @param {?} __0\n    * @return {?}\n    */\n    function (_ref) {\n      var firstChange = _ref.firstChange,\n          currentValue = _ref.currentValue;\n\n      if (!firstChange) {\n        currentValue ? field.formControl.disable() : field.formControl.enable();\n      }\n    });\n\n    if (control.registerOnDisabledChange) {\n      control.registerOnDisabledChange(\n      /**\n      * @param {?} value\n      * @return {?}\n      */\n      function (value) {\n        field.templateOptions['___$disabled'] = value; // TODO remove in V6\n\n        field.options && field.options._markForCheck(field);\n      });\n    }\n  }\n  /** @type {?} */\n\n\n  var parent =\n  /** @type {?} */\n  field.parent.formControl;\n\n  if (!parent || !field.key) {\n    return;\n  }\n  /** @type {?} */\n\n\n  var paths = getKeyPath(field);\n  /** @type {?} */\n\n  var value = getFieldValue(field);\n\n  if (!(isNullOrUndefined(control.value) && isNullOrUndefined(value)) && control.value !== value && control instanceof FormControl) {\n    control.patchValue(value);\n  }\n\n  var _loop = function _loop(i) {\n    /** @type {?} */\n    var path = paths[i];\n\n    if (!parent.get([path])) {\n      updateControl(parent, {\n        emitEvent: emitEvent\n      },\n      /**\n      * @return {?}\n      */\n      function () {\n        return parent.setControl(path, new FormGroup({}));\n      });\n    }\n\n    parent =\n    /** @type {?} */\n    parent.get([path]);\n  };\n\n  for (var i = 0; i < paths.length - 1; i++) {\n    _loop(i);\n  }\n  /** @type {?} */\n\n\n  var key = paths[paths.length - 1];\n\n  if (!field._hide && parent.get([key]) !== control) {\n    updateControl(parent, {\n      emitEvent: emitEvent\n    },\n    /**\n    * @return {?}\n    */\n    function () {\n      return parent.setControl(key, control);\n    });\n  }\n}\n/**\n * @param {?} c\n * @param {?=} onlySelf\n * @return {?}\n */\n\n\nfunction updateValidity(c) {\n  var onlySelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  /** @type {?} */\n  var status = c.status;\n  /** @type {?} */\n\n  var value = c.value;\n  c.updateValueAndValidity({\n    emitEvent: false,\n    onlySelf: onlySelf\n  });\n\n  if (status !== c.status) {\n    /** @type {?} */\n    c.statusChanges.emit(c.status);\n  }\n\n  if (value !== c.value) {\n    /** @type {?} */\n    c.valueChanges.emit(c.value);\n  }\n}\n/**\n * @param {?} form\n * @param {?} opts\n * @param {?} action\n * @return {?}\n */\n\n\nfunction updateControl(form, opts, action) {\n  /**\n   *  workaround for https://github.com/angular/angular/issues/27679\n   */\n  if (form instanceof FormGroup && !form['__patchForEachChild']) {\n    defineHiddenProp(form, '__patchForEachChild', true);\n\n    /** @type {?} */\n    form._forEachChild =\n    /**\n    * @param {?} cb\n    * @return {?}\n    */\n    function (cb) {\n      Object.keys(form.controls).forEach(\n      /**\n      * @param {?} k\n      * @return {?}\n      */\n      function (k) {\n        return form.controls[k] && cb(form.controls[k], k);\n      });\n    };\n  }\n  /**\n   * workaround for https://github.com/angular/angular/issues/20439\n   * @type {?}\n   */\n\n\n  var updateValueAndValidity = form.updateValueAndValidity.bind(form);\n\n  if (opts.emitEvent === false) {\n    form.updateValueAndValidity =\n    /**\n    * @param {?} opts\n    * @return {?}\n    */\n    function (opts) {\n      updateValueAndValidity(Object.assign({}, opts || {}, {\n        emitEvent: false\n      }));\n    };\n  }\n\n  action();\n\n  if (opts.emitEvent === false) {\n    form.updateValueAndValidity = updateValueAndValidity;\n  }\n}\n/**\n * @param {?} form\n * @return {?}\n */\n\n\nfunction clearControl(form) {\n  form['_fields'] && delete form['_fields'];\n  form.setValidators(null);\n  form.setAsyncValidators(null);\n\n  if (form instanceof FormGroup || form instanceof FormArray) {\n    Object.keys(form.controls).forEach(\n    /**\n    * @param {?} k\n    * @return {?}\n    */\n    function (k) {\n      return clearControl(form.controls[k]);\n    });\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar FormlyForm = /*#__PURE__*/function () {\n  /**\n   * @param {?} formlyBuilder\n   * @param {?} formlyConfig\n   * @param {?} ngZone\n   * @param {?} immutable\n   * @param {?} parentFormGroup\n   */\n  function FormlyForm(formlyBuilder, formlyConfig, ngZone, // tslint:disable-next-line\n  immutable, parentFormGroup) {\n    var _this9 = this;\n\n    _classCallCheck(this, FormlyForm);\n\n    this.formlyBuilder = formlyBuilder;\n    this.formlyConfig = formlyConfig;\n    this.ngZone = ngZone;\n    this.parentFormGroup = parentFormGroup;\n    this.modelChange = new EventEmitter();\n    this.immutable = false;\n    this._modelChangeValue = {};\n    this.modelChangeSubs = [];\n    this.modelChange$ = new Subject();\n    this.modelChangeSub = this.modelChange$.pipe(switchMap(\n    /**\n    * @return {?}\n    */\n    function () {\n      return _this9.ngZone.onStable.asObservable().pipe(take(1));\n    })).subscribe(\n    /**\n    * @return {?}\n    */\n    function () {\n      return _this9.ngZone.runGuarded(\n      /**\n      * @return {?}\n      */\n      function () {\n        // runGuarded is used to keep the expression changes in-sync\n        // https://github.com/ngx-formly/ngx-formly/issues/2095\n        _this9.checkExpressionChange();\n\n        _this9.modelChange.emit(_this9._modelChangeValue = clone(_this9.model));\n      });\n    });\n\n    if (immutable !== null) {\n      console.warn(\"NgxFormly: passing 'immutable' attribute to 'formly-form' component is deprecated since v5.5, enable immutable mode through NgModule declaration instead.\");\n    }\n\n    this.immutable = immutable !== null || !!formlyConfig.extras.immutable;\n  }\n  /**\n   * @param {?} model\n   * @return {?}\n   */\n\n\n  _createClass(FormlyForm, [{\n    key: \"model\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      if (!this._model) {\n        this._model = {};\n      }\n\n      return this._model;\n    }\n    /**\n     * @param {?} fields\n     * @return {?}\n     */\n    ,\n    set: function set(model) {\n      this._model = this.immutable ? clone(model) : model;\n    }\n  }, {\n    key: \"fields\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this._fields || [];\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    ,\n    set: function set(fields) {\n      this._fields = this.immutable ? clone(fields) : fields;\n    }\n  }, {\n    key: \"options\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this._options;\n    }\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n    ,\n    set: function set(options) {\n      this._options = this.immutable ? clone(options) : options;\n    }\n  }, {\n    key: \"content\",\n    set: function set(content) {\n      if (content) {\n        /** @type {?} */\n        var hasContent = false;\n        /** @type {?} */\n\n        var node = content.nativeElement.nextSibling;\n\n        while (node && !hasContent) {\n          if (node.nodeType === Node.ELEMENT_NODE || node.nodeType === Node.TEXT_NODE && node.textContent && node.textContent.trim() !== '') {\n            hasContent = true;\n          }\n\n          node = node.nextSibling;\n        }\n\n        if (hasContent) {\n          console.warn(\"NgxFormly: content projection for 'formly-form' component is deprecated since v5.5, you should avoid passing content inside the 'formly-form' tag.\");\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngDoCheck\",\n    value: function ngDoCheck() {\n      if (this.formlyConfig.extras.checkExpressionOn === 'changeDetectionCheck') {\n        this.checkExpressionChange();\n      }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(changes) {\n      // https://github.com/ngx-formly/ngx-formly/issues/2294\n      if (changes.model && this.field) {\n        this.field.model = this.model;\n      }\n\n      if (changes.fields && this.form) {\n        clearControl(this.form);\n      }\n\n      if (changes.fields || changes.form || changes.model && this._modelChangeValue !== changes.model.currentValue) {\n        this.form = this.form || new FormGroup({});\n        this.setOptions();\n        this.options.updateInitialValue();\n        this.clearModelSubscriptions();\n        this.formlyBuilder.buildForm(this.form, this.fields, this.model, this.options);\n        this.trackModelChanges(this.fields);\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.modelChangeSub.unsubscribe();\n      this.clearModelSubscriptions();\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n\n  }, {\n    key: \"changeModel\",\n    value: function changeModel(_ref2) {\n      var key = _ref2.key,\n          value = _ref2.value,\n          field = _ref2.field;\n      assignFieldValue(field, value);\n      this.modelChange$.next();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"setOptions\",\n    value: function setOptions() {\n      var _this10 = this;\n\n      if (!this.options) {\n        this.options = {};\n      }\n\n      if (!this.options.resetModel) {\n        this.options.resetModel =\n        /**\n        * @param {?=} model\n        * @return {?}\n        */\n        function (model) {\n          model = clone(isNullOrUndefined(model) ?\n          /** @type {?} */\n          _this10.options._initialModel : model);\n\n          if (_this10.model) {\n            Object.keys(_this10.model).forEach(\n            /**\n            * @param {?} k\n            * @return {?}\n            */\n            function (k) {\n              return delete _this10.model[k];\n            });\n            Object.assign(_this10.model, model || {});\n          }\n\n          /** @type {?} */\n          _this10.options._buildForm(); // we should call `NgForm::resetForm` to ensure changing `submitted` state after resetting form\n          // but only when the current component is a root one.\n\n\n          if (_this10.options.parentForm && _this10.options.parentForm.control === _this10.form) {\n            _this10.options.parentForm.resetForm(_this10.model);\n          } else {\n            _this10.form.reset(_this10.model);\n          }\n        };\n      }\n\n      if (!this.options.parentForm && this.parentFormGroup) {\n        defineHiddenProp(this.options, 'parentForm', this.parentFormGroup);\n        wrapProperty(this.options.parentForm, 'submitted',\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref3) {\n          var firstChange = _ref3.firstChange;\n\n          if (!firstChange) {\n            _this10.checkExpressionChange();\n\n            /** @type {?} */\n            _this10.options._markForCheck({\n              fieldGroup: _this10.fields,\n              model: _this10.model,\n              formControl: _this10.form,\n              options: _this10.options\n            });\n          }\n        });\n      }\n\n      if (!this.options.updateInitialValue) {\n        this.options.updateInitialValue =\n        /**\n        * @return {?}\n        */\n        function () {\n          return (\n            /** @type {?} */\n            _this10.options._initialModel = clone(_this10.model)\n          );\n        };\n      }\n\n      if (!\n      /** @type {?} */\n      this.options._buildForm) {\n        /** @type {?} */\n        this.options._buildForm =\n        /**\n        * @param {?=} emitModelChange\n        * @return {?}\n        */\n        function () {\n          var emitModelChange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n          _this10.clearModelSubscriptions();\n\n          _this10.formlyBuilder.buildForm(_this10.form, _this10.fields, _this10.model, _this10.options);\n\n          _this10.trackModelChanges(_this10.fields);\n\n          if (emitModelChange) {\n            _this10.modelChange.emit(_this10._modelChangeValue = clone(_this10.model));\n          }\n        };\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"checkExpressionChange\",\n    value: function checkExpressionChange() {\n      if (this.options &&\n      /** @type {?} */\n      this.options._checkField) {\n        /** @type {?} */\n        this.options._checkField({\n          fieldGroup: this.fields,\n          model: this.model,\n          formControl: this.form,\n          options: this.options\n        });\n      }\n    }\n    /**\n     * @private\n     * @param {?} fields\n     * @param {?=} rootKey\n     * @return {?}\n     */\n\n  }, {\n    key: \"trackModelChanges\",\n    value: function trackModelChanges(fields) {\n      var _this11 = this;\n\n      var rootKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      fields.forEach(\n      /**\n      * @param {?} field\n      * @return {?}\n      */\n      function (field) {\n        if (field.key && !field.fieldGroup && field.formControl) {\n          /** @type {?} */\n          var control = field.formControl;\n          /** @type {?} */\n\n          var valueChanges = control.valueChanges.pipe(distinctUntilChanged(\n          /**\n          * @param {?} x\n          * @param {?} y\n          * @return {?}\n          */\n          function (x, y) {\n            if (x !== y || Array.isArray(x) || isObject(x)) {\n              return false;\n            }\n\n            return true;\n          }));\n          var _field$modelOptions = field.modelOptions,\n              updateOn = _field$modelOptions.updateOn,\n              debounce = _field$modelOptions.debounce;\n\n          if ((!updateOn || updateOn === 'change') && debounce && debounce.default > 0) {\n            valueChanges = control.valueChanges.pipe(debounceTime(debounce.default));\n          }\n\n          _this11.modelChangeSubs.push(valueChanges.subscribe(\n          /**\n          * @param {?} value\n          * @return {?}\n          */\n          function (value) {\n            // workaround for https://github.com/angular/angular/issues/13792\n            if (control instanceof FormControl && control['_fields'] && control['_fields'].length > 1) {\n              control.patchValue(value, {\n                emitEvent: false,\n                onlySelf: true\n              });\n            }\n\n            if (field.parsers && field.parsers.length > 0) {\n              field.parsers.forEach(\n              /**\n              * @param {?} parserFn\n              * @return {?}\n              */\n              function (parserFn) {\n                return value = parserFn(value);\n              });\n            }\n\n            _this11.changeModel({\n              key: [].concat(_toConsumableArray(rootKey), _toConsumableArray(getKeyPath(field))).join('.'),\n              value: value,\n              field: field\n            });\n          })); // workaround for v5 (https://github.com/ngx-formly/ngx-formly/issues/2061)\n\n          /** @type {?} */\n\n\n          var observers = control.valueChanges['observers'];\n\n          if (observers && observers.length > 1) {\n            observers.unshift(observers.pop());\n          }\n        }\n\n        if (field.fieldGroup && field.fieldGroup.length > 0) {\n          _this11.trackModelChanges(field.fieldGroup, field.key ? [].concat(_toConsumableArray(rootKey), _toConsumableArray(getKeyPath(field))) : rootKey);\n        }\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"clearModelSubscriptions\",\n    value: function clearModelSubscriptions() {\n      this.modelChangeSubs.forEach(\n      /**\n      * @param {?} sub\n      * @return {?}\n      */\n      function (sub) {\n        return sub.unsubscribe();\n      });\n      this.modelChangeSubs = [];\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"field\",\n    get: function get() {\n      return this.fields && this.fields[0] && this.fields[0].parent;\n    }\n  }]);\n\n  return FormlyForm;\n}();\n\nFormlyForm.ɵfac = function FormlyForm_Factory(t) {\n  return new (t || FormlyForm)(ɵngcc0.ɵɵdirectiveInject(FormlyFormBuilder), ɵngcc0.ɵɵdirectiveInject(FormlyConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵinjectAttribute('immutable'), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FormGroupDirective, 8));\n};\n\nFormlyForm.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: FormlyForm,\n  selectors: [[\"formly-form\"]],\n  viewQuery: function FormlyForm_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(_c0, 5);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.content = _t.first);\n    }\n  },\n  inputs: {\n    model: \"model\",\n    fields: \"fields\",\n    options: \"options\",\n    form: \"form\"\n  },\n  outputs: {\n    modelChange: \"modelChange\"\n  },\n  features: [ɵngcc0.ɵɵProvidersFeature([FormlyFormBuilder]), ɵngcc0.ɵɵNgOnChangesFeature],\n  ngContentSelectors: _c1,\n  decls: 4,\n  vars: 1,\n  consts: [[\"hide-deprecation\", \"\", 3, \"form\", \"options\", \"model\", \"field\", 4, \"ngFor\", \"ngForOf\"], [\"content\", \"\"], [\"hide-deprecation\", \"\", 3, \"form\", \"options\", \"model\", \"field\"]],\n  template: function FormlyForm_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵprojectionDef();\n      ɵngcc0.ɵɵtemplate(0, FormlyForm_formly_field_0_Template, 1, 4, \"formly-field\", 0);\n      ɵngcc0.ɵɵelementContainerStart(1, null, 1);\n      ɵngcc0.ɵɵprojection(3);\n      ɵngcc0.ɵɵelementContainerEnd();\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.fields);\n    }\n  },\n  directives: function directives() {\n    return [ɵngcc2.NgForOf, FormlyField];\n  },\n  encapsulation: 2\n});\n/** @nocollapse */\n\nFormlyForm.ctorParameters = function () {\n  return [{\n    type: FormlyFormBuilder\n  }, {\n    type: FormlyConfig\n  }, {\n    type: NgZone\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Attribute,\n      args: ['immutable']\n    }]\n  }, {\n    type: FormGroupDirective,\n    decorators: [{\n      type: Optional\n    }]\n  }];\n};\n\nFormlyForm.propDecorators = {\n  form: [{\n    type: Input\n  }],\n  model: [{\n    type: Input\n  }],\n  fields: [{\n    type: Input\n  }],\n  options: [{\n    type: Input\n  }],\n  modelChange: [{\n    type: Output\n  }],\n  content: [{\n    type: ViewChild,\n    args: ['content']\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormlyForm, [{\n    type: Component,\n    args: [{\n      selector: 'formly-form',\n      template: \"\\n    <formly-field *ngFor=\\\"let field of fields\\\"\\n      hide-deprecation\\n      [form]=\\\"field.form\\\"\\n      [options]=\\\"field.options\\\"\\n      [model]=\\\"field.model\\\"\\n      [field]=\\\"field\\\">\\n    </formly-field>\\n    <ng-container #content>\\n      <ng-content></ng-content>\\n    </ng-container>\\n  \",\n      providers: [FormlyFormBuilder]\n    }]\n  }], function () {\n    return [{\n      type: FormlyFormBuilder\n    }, {\n      type: FormlyConfig\n    }, {\n      type: ɵngcc0.NgZone\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Attribute,\n        args: ['immutable']\n      }]\n    }, {\n      type: ɵngcc1.FormGroupDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, {\n    modelChange: [{\n      type: Output\n    }],\n    model: [{\n      type: Input\n    }],\n    fields: [{\n      type: Input\n    }],\n    options: [{\n      type: Input\n    }],\n    content: [{\n      type: ViewChild,\n      args: ['content']\n    }],\n    form: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar FormlyField = /*#__PURE__*/function () {\n  /**\n   * @param {?} formlyConfig\n   * @param {?} renderer\n   * @param {?} resolver\n   * @param {?} elementRef\n   * @param {?} hideDeprecation\n   */\n  function FormlyField(formlyConfig, renderer, resolver, elementRef, // tslint:disable-next-line\n  hideDeprecation) {\n    _classCallCheck(this, FormlyField);\n\n    this.formlyConfig = formlyConfig;\n    this.renderer = renderer;\n    this.resolver = resolver;\n    this.elementRef = elementRef;\n    this.warnDeprecation = false;\n    this.modelChange = new EventEmitter();\n    this.hostObservers = [];\n    this.componentRefs = [];\n    this.hooksObservers = [];\n    this.detectFieldBuild = false;\n    this.warnDeprecation = hideDeprecation === null;\n  }\n  /**\n   * @param {?} m\n   * @return {?}\n   */\n\n\n  _createClass(FormlyField, [{\n    key: \"model\",\n    set: function set(m) {\n      this.warnDeprecation && console.warn(\"NgxFormly: passing 'model' input to '\".concat(this.constructor.name, \"' component is not required anymore, you may remove it!\"));\n    }\n    /**\n     * @param {?} form\n     * @return {?}\n     */\n\n  }, {\n    key: \"form\",\n    set: function set(form) {\n      this.warnDeprecation && console.warn(\"NgxFormly: passing 'form' input to '\".concat(this.constructor.name, \"' component is not required anymore, you may remove it!\"));\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"options\",\n    set: function set(options) {\n      this.warnDeprecation && console.warn(\"NgxFormly: passing 'options' input to '\".concat(this.constructor.name, \"' component is not required anymore, you may remove it!\"));\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngAfterContentInit\",\n    value: function ngAfterContentInit() {\n      this.triggerHook('afterContentInit');\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngAfterContentChecked\",\n    value: function ngAfterContentChecked() {\n      this.triggerHook('afterContentChecked');\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngAfterViewInit\",\n    value: function ngAfterViewInit() {\n      this.triggerHook('afterViewInit');\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngAfterViewChecked\",\n    value: function ngAfterViewChecked() {\n      this.triggerHook('afterViewChecked');\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngDoCheck\",\n    value: function ngDoCheck() {\n      this.triggerHook('doCheck');\n\n      if (this.detectFieldBuild && this.field && this.field.options) {\n        this.render();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      this.triggerHook('onInit');\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(changes) {\n      this.triggerHook('onChanges', changes);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.resetRefs(this.field);\n      this.hostObservers.forEach(\n      /**\n      * @param {?} unsubscribe\n      * @return {?}\n      */\n      function (unsubscribe) {\n        return unsubscribe();\n      });\n      this.hooksObservers.forEach(\n      /**\n      * @param {?} unsubscribe\n      * @return {?}\n      */\n      function (unsubscribe) {\n        return unsubscribe();\n      });\n      this.triggerHook('onDestroy');\n    }\n    /**\n     * @private\n     * @param {?} containerRef\n     * @param {?} f\n     * @param {?=} wrappers\n     * @return {?}\n     */\n\n  }, {\n    key: \"renderField\",\n    value: function renderField(containerRef, f) {\n      var _this12 = this;\n\n      var wrappers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n      if (this.containerRef === containerRef) {\n        this.resetRefs(this.field);\n        this.containerRef.clear();\n        wrappers = this.field ? this.field.wrappers : [];\n      }\n\n      if (wrappers && wrappers.length > 0) {\n        var _wrappers = wrappers,\n            _wrappers2 = _toArray(_wrappers),\n            wrapper = _wrappers2[0],\n            wps = _wrappers2.slice(1);\n\n        var _this$formlyConfig$ge = this.formlyConfig.getWrapper(wrapper),\n            component = _this$formlyConfig$ge.component;\n        /** @type {?} */\n\n\n        var ref = containerRef.createComponent(this.resolver.resolveComponentFactory(component));\n        this.attachComponentRef(ref, f);\n        wrapProperty(ref.instance, 'fieldComponent',\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref4) {\n          var firstChange = _ref4.firstChange,\n              previousValue = _ref4.previousValue,\n              currentValue = _ref4.currentValue;\n\n          if (currentValue) {\n            if (previousValue && previousValue['_lContainer'] === currentValue['_lContainer']) {\n              return;\n            }\n            /** @type {?} */\n\n\n            var viewRef = previousValue ? previousValue.detach() : null;\n\n            if (viewRef && !viewRef.destroyed) {\n              currentValue.insert(viewRef);\n            } else {\n              _this12.renderField(currentValue, f, wps);\n            }\n\n            !firstChange && ref.changeDetectorRef.detectChanges();\n          }\n        });\n      } else if (f && f.type) {\n        var _this$formlyConfig$ge2 = this.formlyConfig.getType(f.type),\n            _component = _this$formlyConfig$ge2.component;\n        /** @type {?} */\n\n\n        var _ref5 = containerRef.createComponent(this.resolver.resolveComponentFactory(_component));\n\n        this.attachComponentRef(_ref5, f);\n      }\n    }\n    /**\n     * @private\n     * @param {?} name\n     * @param {?=} changes\n     * @return {?}\n     */\n\n  }, {\n    key: \"triggerHook\",\n    value: function triggerHook(name, changes) {\n      if (this.field && this.field.hooks && this.field.hooks[name]) {\n        if (!changes || changes.field) {\n          /** @type {?} */\n          var r = this.field.hooks[name](this.field);\n\n          if (isObservable(r) && ['onInit', 'afterContentInit', 'afterViewInit'].indexOf(name) !== -1) {\n            /** @type {?} */\n            var sub = r.subscribe();\n            this.hooksObservers.push(\n            /**\n            * @return {?}\n            */\n            function () {\n              return sub.unsubscribe();\n            });\n          }\n        }\n      }\n\n      if (this.field && this.field.lifecycle && this.field.lifecycle[name]) {\n        this.field.lifecycle[name](this.field.form, this.field, this.field.model, this.field.options);\n      }\n\n      if (name === 'onChanges' && changes.field) {\n        this.resetRefs(changes.field.previousValue);\n        this.render();\n      }\n    }\n    /**\n     * @private\n     * @template T\n     * @param {?} ref\n     * @param {?} field\n     * @return {?}\n     */\n\n  }, {\n    key: \"attachComponentRef\",\n    value: function attachComponentRef(ref, field) {\n      this.componentRefs.push(ref);\n\n      field._componentRefs.push(ref);\n\n      Object.assign(ref.instance, {\n        field: field\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this13 = this;\n\n      if (!this.field) {\n        return;\n      } // require Formly build\n\n\n      if (!this.field.options) {\n        this.detectFieldBuild = true;\n        return;\n      }\n\n      this.detectFieldBuild = false;\n      this.hostObservers.forEach(\n      /**\n      * @param {?} unsubscribe\n      * @return {?}\n      */\n      function (unsubscribe) {\n        return unsubscribe();\n      });\n      this.hostObservers = [wrapProperty(this.field, 'hide',\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      function (_ref6) {\n        var firstChange = _ref6.firstChange,\n            currentValue = _ref6.currentValue;\n\n        if (!_this13.formlyConfig.extras.lazyRender) {\n          firstChange && _this13.renderField(_this13.containerRef, _this13.field);\n\n          if (!firstChange || firstChange && currentValue) {\n            _this13.renderer.setStyle(_this13.elementRef.nativeElement, 'display', currentValue ? 'none' : '');\n          }\n        } else {\n          if (currentValue) {\n            _this13.containerRef.clear();\n\n            if (_this13.field.className) {\n              _this13.renderer.removeAttribute(_this13.elementRef.nativeElement, 'class');\n            }\n          } else {\n            _this13.renderField(_this13.containerRef, _this13.field);\n\n            if (_this13.field.className) {\n              _this13.renderer.setAttribute(_this13.elementRef.nativeElement, 'class', _this13.field.className);\n            }\n          }\n        }\n      }), wrapProperty(this.field, 'className',\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      function (_ref7) {\n        var firstChange = _ref7.firstChange,\n            currentValue = _ref7.currentValue;\n\n        if ((!firstChange || firstChange && currentValue) && (!_this13.formlyConfig.extras.lazyRender || _this13.field.hide !== true)) {\n          _this13.renderer.setAttribute(_this13.elementRef.nativeElement, 'class', currentValue);\n        }\n      })];\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @return {?}\n     */\n\n  }, {\n    key: \"resetRefs\",\n    value: function resetRefs(field) {\n      var _this14 = this;\n\n      if (field) {\n        if (field._componentRefs) {\n          field._componentRefs = field._componentRefs.filter(\n          /**\n          * @param {?} ref\n          * @return {?}\n          */\n          function (ref) {\n            return _this14.componentRefs.indexOf(ref) === -1;\n          });\n        } else {\n          defineHiddenProp(this.field, '_componentRefs', []);\n        }\n      }\n\n      this.componentRefs = [];\n    }\n  }]);\n\n  return FormlyField;\n}();\n\nFormlyField.ɵfac = function FormlyField_Factory(t) {\n  return new (t || FormlyField)(ɵngcc0.ɵɵdirectiveInject(FormlyConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵinjectAttribute('hide-deprecation'));\n};\n\nFormlyField.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: FormlyField,\n  selectors: [[\"formly-field\"]],\n  viewQuery: function FormlyField_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(_c2, 7, ViewContainerRef);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.containerRef = _t.first);\n    }\n  },\n  inputs: {\n    model: \"model\",\n    form: \"form\",\n    options: \"options\",\n    field: \"field\"\n  },\n  outputs: {\n    modelChange: \"modelChange\"\n  },\n  features: [ɵngcc0.ɵɵNgOnChangesFeature],\n  decls: 2,\n  vars: 0,\n  consts: [[\"container\", \"\"]],\n  template: function FormlyField_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵtemplate(0, FormlyField_ng_template_0_Template, 0, 0, \"ng-template\", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);\n    }\n  },\n  encapsulation: 2\n});\n/** @nocollapse */\n\nFormlyField.ctorParameters = function () {\n  return [{\n    type: FormlyConfig\n  }, {\n    type: Renderer2\n  }, {\n    type: ComponentFactoryResolver\n  }, {\n    type: ElementRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Attribute,\n      args: ['hide-deprecation']\n    }]\n  }];\n};\n\nFormlyField.propDecorators = {\n  field: [{\n    type: Input\n  }],\n  model: [{\n    type: Input\n  }],\n  form: [{\n    type: Input\n  }],\n  options: [{\n    type: Input\n  }],\n  modelChange: [{\n    type: Output\n  }],\n  containerRef: [{\n    type: ViewChild,\n    args: ['container',\n    /** @type {?} */\n    {\n      read: ViewContainerRef,\n      static: true\n    }]\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormlyField, [{\n    type: Component,\n    args: [{\n      selector: 'formly-field',\n      template: \"<ng-template #container></ng-template>\"\n    }]\n  }], function () {\n    return [{\n      type: FormlyConfig\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: ɵngcc0.ComponentFactoryResolver\n    }, {\n      type: ɵngcc0.ElementRef\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Attribute,\n        args: ['hide-deprecation']\n      }]\n    }];\n  }, {\n    modelChange: [{\n      type: Output\n    }],\n    model: [{\n      type: Input\n    }],\n    form: [{\n      type: Input\n    }],\n    options: [{\n      type: Input\n    }],\n    field: [{\n      type: Input\n    }],\n    containerRef: [{\n      type: ViewChild,\n      args: ['container',\n      /** @type {?} */\n      {\n        read: ViewContainerRef,\n        static: true\n      }]\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar FormlyAttributes = /*#__PURE__*/function () {\n  /**\n   * @param {?} renderer\n   * @param {?} elementRef\n   * @param {?} _document\n   */\n  function FormlyAttributes(renderer, elementRef, _document) {\n    var _this15 = this;\n\n    _classCallCheck(this, FormlyAttributes);\n\n    this.renderer = renderer;\n    this.elementRef = elementRef;\n    this.uiAttributesCache = {};\n    this.uiAttributes = null;\n    /**\n     * HostBinding doesn't register listeners conditionally which may produce some perf issues.\n     *\n     * Formly issue: https://github.com/ngx-formly/ngx-formly/issues/1991\n     */\n\n    this.uiEvents = {\n      listeners: [],\n      events: ['click', 'keyup', 'keydown', 'keypress', 'focus', 'blur', 'change'],\n      callback:\n      /**\n      * @param {?} eventName\n      * @param {?} $event\n      * @return {?}\n      */\n      function callback(eventName, $event) {\n        switch (eventName) {\n          case 'focus':\n            return _this15.onFocus($event);\n\n          case 'blur':\n            return _this15.onBlur($event);\n\n          case 'change':\n            return _this15.onChange($event);\n\n          default:\n            return _this15.to[eventName](_this15.field, $event);\n        }\n      }\n    };\n    this.document = _document;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(FormlyAttributes, [{\n    key: \"to\",\n    get: function get() {\n      return this.field.templateOptions || {};\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"fieldAttrElements\",\n    get: function get() {\n      return this.field && this.field['_elementRefs'] || [];\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(changes) {\n      var _this16 = this;\n\n      if (changes.field) {\n        this.field.name && this.setAttribute('name', this.field.name);\n        this.uiEvents.listeners.forEach(\n        /**\n        * @param {?} listener\n        * @return {?}\n        */\n        function (listener) {\n          return listener();\n        });\n        this.uiEvents.events.forEach(\n        /**\n        * @param {?} eventName\n        * @return {?}\n        */\n        function (eventName) {\n          if (_this16.to && _this16.to[eventName] || ['focus', 'blur', 'change'].indexOf(eventName) !== -1) {\n            _this16.uiEvents.listeners.push(_this16.renderer.listen(_this16.elementRef.nativeElement, eventName,\n            /**\n            * @param {?} e\n            * @return {?}\n            */\n            function (e) {\n              return _this16.uiEvents.callback(eventName, e);\n            }));\n          }\n        });\n\n        if (this.to && this.to.attributes) {\n          wrapProperty(this.to, 'attributes',\n          /**\n          * @param {?} __0\n          * @return {?}\n          */\n          function (_ref8) {\n            var currentValue = _ref8.currentValue,\n                previousValue = _ref8.previousValue;\n\n            if (previousValue) {\n              Object.keys(previousValue).forEach(\n              /**\n              * @param {?} attr\n              * @return {?}\n              */\n              function (attr) {\n                return _this16.removeAttribute(attr);\n              });\n            }\n\n            if (currentValue) {\n              Object.keys(currentValue).forEach(\n              /**\n              * @param {?} attr\n              * @return {?}\n              */\n              function (attr) {\n                if (currentValue[attr] != null) {\n                  _this16.setAttribute(attr, currentValue[attr]);\n                }\n              });\n            }\n          });\n        }\n\n        this.detachElementRef(changes.field.previousValue);\n        this.attachElementRef(changes.field.currentValue);\n\n        if (this.fieldAttrElements.length === 1) {\n          !this.id && this.field.id && this.setAttribute('id', this.field.id);\n          wrapProperty(this.field, 'focus',\n          /**\n          * @param {?} __0\n          * @return {?}\n          */\n          function (_ref9) {\n            var currentValue = _ref9.currentValue;\n\n            _this16.toggleFocus(currentValue);\n          });\n        }\n      }\n\n      if (changes.id) {\n        this.setAttribute('id', this.id);\n      }\n    }\n    /**\n     * We need to re-evaluate all the attributes on every change detection cycle, because\n     * by using a HostBinding we run into certain edge cases. This means that whatever logic\n     * is in here has to be super lean or we risk seriously damaging or destroying the performance.\n     *\n     * Formly issue: https://github.com/ngx-formly/ngx-formly/issues/1317\n     * Material issue: https://github.com/angular/components/issues/14024\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngDoCheck\",\n    value: function ngDoCheck() {\n      var _this17 = this;\n\n      if (!this.uiAttributes) {\n        /** @type {?} */\n        var element =\n        /** @type {?} */\n        this.elementRef.nativeElement;\n        this.uiAttributes = [].concat(FORMLY_VALIDATORS, ['tabindex', 'placeholder', 'readonly', 'disabled', 'step']).filter(\n        /**\n        * @param {?} attr\n        * @return {?}\n        */\n        function (attr) {\n          return !element.hasAttribute || !element.hasAttribute(attr);\n        });\n      }\n\n      this.uiAttributes.forEach(\n      /**\n      * @param {?} attr\n      * @return {?}\n      */\n      function (attr) {\n        /** @type {?} */\n        var value = _this17.to[attr];\n\n        if (_this17.uiAttributesCache[attr] !== value && (!_this17.to.attributes || !_this17.to.attributes.hasOwnProperty(attr.toLowerCase()))) {\n          _this17.uiAttributesCache[attr] = value;\n\n          if (value || value === 0) {\n            _this17.setAttribute(attr, value === true ? attr : \"\".concat(value));\n          } else {\n            _this17.removeAttribute(attr);\n          }\n        }\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.uiEvents.listeners.forEach(\n      /**\n      * @param {?} listener\n      * @return {?}\n      */\n      function (listener) {\n        return listener();\n      });\n      this.detachElementRef(this.field);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n  }, {\n    key: \"toggleFocus\",\n    value: function toggleFocus(value) {\n      var _this18 = this;\n\n      /** @type {?} */\n      var element = this.fieldAttrElements ? this.fieldAttrElements[0] : null;\n\n      if (!element || !element.nativeElement.focus) {\n        return;\n      }\n      /** @type {?} */\n\n\n      var isFocused = !!this.document.activeElement && this.fieldAttrElements.some(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      function (_ref10) {\n        var nativeElement = _ref10.nativeElement;\n        return _this18.document.activeElement === nativeElement || nativeElement.contains(_this18.document.activeElement);\n      });\n\n      if (value && !isFocused) {\n        element.nativeElement.focus();\n      } else if (!value && isFocused) {\n        element.nativeElement.blur();\n      }\n    }\n    /**\n     * @param {?} $event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onFocus\",\n    value: function onFocus($event) {\n      this.field['___$focus'] = true;\n\n      if (this.to.focus) {\n        this.to.focus(this.field, $event);\n      }\n    }\n    /**\n     * @param {?} $event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onBlur\",\n    value: function onBlur($event) {\n      this.field['___$focus'] = false;\n\n      if (this.to.blur) {\n        this.to.blur(this.field, $event);\n      }\n    } // handle custom `change` event, for regular ones rely on DOM listener\n\n    /**\n     * @param {?} $event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onHostChange\",\n    value: function onHostChange($event) {\n      if ($event instanceof Event) {\n        return;\n      }\n\n      this.onChange($event);\n    }\n    /**\n     * @param {?} $event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onChange\",\n    value: function onChange($event) {\n      if (this.to.change) {\n        this.to.change(this.field, $event);\n      }\n\n      if (this.field.formControl) {\n        this.field.formControl.markAsDirty();\n      }\n    }\n    /**\n     * @private\n     * @param {?} f\n     * @return {?}\n     */\n\n  }, {\n    key: \"attachElementRef\",\n    value: function attachElementRef(f) {\n      if (!f) {\n        return;\n      }\n\n      if (f['_elementRefs'] && f['_elementRefs'].indexOf(this.elementRef) === -1) {\n        f['_elementRefs'].push(this.elementRef);\n      } else {\n        defineHiddenProp(f, '_elementRefs', [this.elementRef]);\n      }\n    }\n    /**\n     * @private\n     * @param {?} f\n     * @return {?}\n     */\n\n  }, {\n    key: \"detachElementRef\",\n    value: function detachElementRef(f) {\n      /** @type {?} */\n      var index = f && f['_elementRefs'] ? this.fieldAttrElements.indexOf(this.elementRef) : -1;\n\n      if (index !== -1) {\n        this.field['_elementRefs'].splice(index, 1);\n      }\n    }\n    /**\n     * @private\n     * @param {?} attr\n     * @param {?} value\n     * @return {?}\n     */\n\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(attr, value) {\n      this.renderer.setAttribute(this.elementRef.nativeElement, attr, value);\n    }\n    /**\n     * @private\n     * @param {?} attr\n     * @return {?}\n     */\n\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(attr) {\n      this.renderer.removeAttribute(this.elementRef.nativeElement, attr);\n    }\n  }]);\n\n  return FormlyAttributes;\n}();\n\nFormlyAttributes.ɵfac = function FormlyAttributes_Factory(t) {\n  return new (t || FormlyAttributes)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n};\n\nFormlyAttributes.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: FormlyAttributes,\n  selectors: [[\"\", \"formlyAttributes\", \"\"]],\n  hostBindings: function FormlyAttributes_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"change\", function FormlyAttributes_change_HostBindingHandler($event) {\n        return ctx.onHostChange($event);\n      });\n    }\n  },\n  inputs: {\n    field: [\"formlyAttributes\", \"field\"],\n    id: \"id\"\n  },\n  features: [ɵngcc0.ɵɵNgOnChangesFeature]\n});\n/** @nocollapse */\n\nFormlyAttributes.ctorParameters = function () {\n  return [{\n    type: Renderer2\n  }, {\n    type: ElementRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }];\n};\n\nFormlyAttributes.propDecorators = {\n  field: [{\n    type: Input,\n    args: ['formlyAttributes']\n  }],\n  id: [{\n    type: Input\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormlyAttributes, [{\n    type: Directive,\n    args: [{\n      selector: '[formlyAttributes]',\n      host: {\n        '(change)': 'onHostChange($event)'\n      }\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.Renderer2\n    }, {\n      type: ɵngcc0.ElementRef\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, {\n    field: [{\n      type: Input,\n      args: ['formlyAttributes']\n    }],\n    id: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @abstract\n * @template F\n */\n\n\nvar FieldType = /*#__PURE__*/function () {\n  function FieldType() {\n    _classCallCheck(this, FieldType);\n  }\n\n  _createClass(FieldType, [{\n    key: \"model\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.field.model;\n    }\n    /**\n     * @param {?} m\n     * @return {?}\n     */\n    ,\n    set: function set(m) {\n      console.warn(\"NgxFormly: passing 'model' input to '\".concat(this.constructor.name, \"' component is not required anymore, you may remove it!\"));\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"form\",\n    get: function get() {\n      return (\n        /** @type {?} */\n        this.field.parent.formControl\n      );\n    }\n    /**\n     * @param {?} form\n     * @return {?}\n     */\n    ,\n    set: function set(form) {\n      console.warn(\"NgxFormly: passing 'form' input to '\".concat(this.constructor.name, \"' component is not required anymore, you may remove it!\"));\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this.field.options;\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    ,\n    set: function set(options) {\n      console.warn(\"NgxFormly: passing 'options' input to '\".concat(this.constructor.name, \"' component is not required anymore, you may remove it!\"));\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"key\",\n    get: function get() {\n      return this.field.key;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"formControl\",\n    get: function get() {\n      return (\n        /** @type {?} */\n        this.field.formControl\n      );\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"to\",\n    get: function get() {\n      return this.field.templateOptions || {};\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"showError\",\n    get: function get() {\n      return this.options.showError(this);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this.field.id;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"formState\",\n    get: function get() {\n      return this.options.formState || {};\n    }\n  }]);\n\n  return FieldType;\n}();\n\nFieldType.ɵfac = function FieldType_Factory(t) {\n  return new (t || FieldType)();\n};\n\nFieldType.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: FieldType,\n  inputs: {\n    model: \"model\",\n    form: \"form\",\n    options: \"options\",\n    field: \"field\"\n  }\n});\nFieldType.propDecorators = {\n  field: [{\n    type: Input\n  }],\n  model: [{\n    type: Input\n  }],\n  form: [{\n    type: Input\n  }],\n  options: [{\n    type: Input\n  }]\n};\n/**\n * @deprecated use `FieldType` instead\n * @abstract\n */\n\nvar Field = /*#__PURE__*/function (_FieldType) {\n  _inherits(Field, _FieldType);\n\n  var _super = _createSuper(Field);\n\n  function Field() {\n    var _this19;\n\n    _classCallCheck(this, Field);\n\n    _this19 = _super.call(this);\n    console.warn(\"NgxFormly: 'Field' has been renamed to 'FieldType', extend 'FieldType' instead.\");\n    return _this19;\n  }\n\n  return _createClass(Field);\n}(FieldType);\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// TODO remove `selector` in V6\n// tslint:disable-next-line\n\n/**\n * @abstract\n * @template F\n */\n\n\nvar FieldArrayType = /*#__PURE__*/function (_FieldType2) {\n  _inherits(FieldArrayType, _FieldType2);\n\n  var _super2 = _createSuper(FieldArrayType);\n\n  /**\n   * @param {?=} builder\n   */\n  function FieldArrayType(builder) {\n    var _this20;\n\n    _classCallCheck(this, FieldArrayType);\n\n    _this20 = _super2.call(this);\n    _this20.defaultOptions = {\n      defaultValue: []\n    };\n\n    if (builder instanceof FormlyFormBuilder) {\n      console.warn(\"NgxFormly: passing 'FormlyFormBuilder' to '\".concat(_this20.constructor.name, \"' type is not required anymore, you may remove it!\"));\n    }\n\n    return _this20;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(FieldArrayType, [{\n    key: \"formControl\",\n    get: function get() {\n      return (\n        /** @type {?} */\n        this.field.formControl\n      );\n    }\n    /**\n     * @param {?} field\n     * @return {?}\n     */\n\n  }, {\n    key: \"onPopulate\",\n    value: function onPopulate(field) {\n      if (!field.formControl && field.key) {\n        /** @type {?} */\n        var control = findControl(field);\n        registerControl(field, control ? control : new FormArray([], {\n          updateOn: field.modelOptions.updateOn\n        }));\n      }\n\n      field.fieldGroup = field.fieldGroup || [];\n      /** @type {?} */\n\n      var length = field.model ? field.model.length : 0;\n\n      if (field.fieldGroup.length > length) {\n        for (var i = field.fieldGroup.length - 1; i >= length; --i) {\n          unregisterControl(field.fieldGroup[i]);\n          field.fieldGroup.splice(i, 1);\n        }\n      }\n\n      for (var _i = field.fieldGroup.length; _i < length; _i++) {\n        /** @type {?} */\n        var f = Object.assign({}, clone(field.fieldArray), {\n          key: \"\".concat(_i)\n        });\n        field.fieldGroup.push(f);\n      }\n    }\n    /**\n     * @param {?=} i\n     * @param {?=} initialModel\n     * @param {?=} __2\n     * @return {?}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(i, initialModel) {\n      var _ref11 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n        markAsDirty: true\n      },\n          markAsDirty = _ref11.markAsDirty;\n\n      i = isNullOrUndefined(i) ? this.field.fieldGroup.length : i;\n\n      if (!this.model) {\n        assignFieldValue(this.field, []);\n      }\n\n      this.model.splice(i, 0, initialModel ? clone(initialModel) : undefined);\n\n      /** @type {?} */\n      this.options._buildForm(true);\n\n      markAsDirty && this.formControl.markAsDirty();\n    }\n    /**\n     * @param {?} i\n     * @param {?=} __1\n     * @return {?}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(i) {\n      var _ref12 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        markAsDirty: true\n      },\n          markAsDirty = _ref12.markAsDirty;\n\n      this.model.splice(i, 1);\n      unregisterControl(this.field.fieldGroup[i], true);\n      this.field.fieldGroup.splice(i, 1);\n      this.field.fieldGroup.forEach(\n      /**\n      * @param {?} f\n      * @param {?} key\n      * @return {?}\n      */\n      function (f, key) {\n        return f.key = \"\".concat(key);\n      });\n\n      /** @type {?} */\n      this.options._buildForm(true);\n\n      markAsDirty && this.formControl.markAsDirty();\n    }\n  }]);\n\n  return FieldArrayType;\n}(FieldType);\n\nFieldArrayType.ɵfac = function FieldArrayType_Factory(t) {\n  return new (t || FieldArrayType)(ɵngcc0.ɵɵdirectiveInject(FORMLY_CONFIG, 8));\n};\n\nFieldArrayType.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: FieldArrayType,\n  selectors: [[\"fieldArray\"]],\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n/** @nocollapse */\n\nFieldArrayType.ctorParameters = function () {\n  return [{\n    type: FormlyFormBuilder,\n    decorators: [{\n      type: Inject,\n      args: [FORMLY_CONFIG]\n    }, {\n      type: Optional\n    }]\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FieldArrayType, [{\n    type: Directive,\n    args: [{\n      selector: '[ɵfieldArray]'\n    }]\n  }], function () {\n    return [{\n      type: FormlyFormBuilder,\n      decorators: [{\n        type: Inject,\n        args: [FORMLY_CONFIG]\n      }, {\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @abstract\n * @template F\n */\n\n\nvar FieldWrapper = /*#__PURE__*/function (_FieldType3) {\n  _inherits(FieldWrapper, _FieldType3);\n\n  var _super3 = _createSuper(FieldWrapper);\n\n  function FieldWrapper() {\n    _classCallCheck(this, FieldWrapper);\n\n    return _super3.apply(this, arguments);\n  }\n\n  return _createClass(FieldWrapper);\n}(FieldType);\n\nFieldWrapper.ɵfac = /*@__PURE__*/function () {\n  var ɵFieldWrapper_BaseFactory;\n  return function FieldWrapper_Factory(t) {\n    return (ɵFieldWrapper_BaseFactory || (ɵFieldWrapper_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(FieldWrapper)))(t || FieldWrapper);\n  };\n}();\n\nFieldWrapper.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: FieldWrapper,\n  viewQuery: function FieldWrapper_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(_c3, 5, ViewContainerRef);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fieldComponent = _t.first);\n    }\n  },\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\nFieldWrapper.propDecorators = {\n  fieldComponent: [{\n    type: ViewChild,\n    args: ['fieldComponent',\n    /** @type {?} */\n    {\n      read: ViewContainerRef,\n      static: false\n    }]\n  }]\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nvar FormlyGroup = /*#__PURE__*/function (_FieldType4) {\n  _inherits(FormlyGroup, _FieldType4);\n\n  var _super4 = _createSuper(FormlyGroup);\n\n  function FormlyGroup() {\n    var _this21;\n\n    _classCallCheck(this, FormlyGroup);\n\n    _this21 = _super4.apply(this, arguments);\n    _this21.defaultOptions = {\n      defaultValue: {}\n    };\n    return _this21;\n  }\n\n  return _createClass(FormlyGroup);\n}(FieldType);\n\nFormlyGroup.ɵfac = /*@__PURE__*/function () {\n  var ɵFormlyGroup_BaseFactory;\n  return function FormlyGroup_Factory(t) {\n    return (ɵFormlyGroup_BaseFactory || (ɵFormlyGroup_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(FormlyGroup)))(t || FormlyGroup);\n  };\n}();\n\nFormlyGroup.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: FormlyGroup,\n  selectors: [[\"formly-group\"]],\n  hostVars: 2,\n  hostBindings: function FormlyGroup_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵclassMap(ctx.field.fieldGroupClassName || \"\");\n    }\n  },\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n  ngContentSelectors: _c1,\n  decls: 2,\n  vars: 1,\n  consts: [[3, \"field\", 4, \"ngFor\", \"ngForOf\"], [3, \"field\"]],\n  template: function FormlyGroup_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵprojectionDef();\n      ɵngcc0.ɵɵtemplate(0, FormlyGroup_formly_field_0_Template, 1, 1, \"formly-field\", 0);\n      ɵngcc0.ɵɵprojection(1);\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.field.fieldGroup);\n    }\n  },\n  directives: [ɵngcc2.NgForOf, FormlyField],\n  encapsulation: 2\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormlyGroup, [{\n    type: Component,\n    args: [{\n      selector: 'formly-group',\n      template: \"\\n    <formly-field *ngFor=\\\"let f of field.fieldGroup\\\" [field]=\\\"f\\\"></formly-field>\\n    <ng-content></ng-content>\\n  \",\n      host: {\n        '[class]': 'field.fieldGroupClassName || \"\"'\n      }\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar FormlyValidationMessage = /*#__PURE__*/function () {\n  /**\n   * @param {?} formlyConfig\n   */\n  function FormlyValidationMessage(formlyConfig) {\n    _classCallCheck(this, FormlyValidationMessage);\n\n    this.formlyConfig = formlyConfig;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(FormlyValidationMessage, [{\n    key: \"ngOnChanges\",\n    value: function ngOnChanges() {\n      var _this22 = this;\n\n      this.errorMessage$ = merge(this.field.formControl.statusChanges, !this.field.options ? of(null) : this.field.options.fieldChanges.pipe(filter(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      function (_ref13) {\n        var field = _ref13.field,\n            type = _ref13.type,\n            property = _ref13.property;\n        return field === _this22.field && type === 'expressionChanges' && property.indexOf('validation') !== -1;\n      }))).pipe(startWith(null), switchMap(\n      /**\n      * @return {?}\n      */\n      function () {\n        return isObservable(_this22.errorMessage) ? _this22.errorMessage : of(_this22.errorMessage);\n      }));\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"errorMessage\",\n    get: function get() {\n      /** @type {?} */\n      var fieldForm = this.field.formControl;\n\n      for (var error in fieldForm.errors) {\n        if (fieldForm.errors.hasOwnProperty(error)) {\n          /** @type {?} */\n          var message = this.formlyConfig.getValidatorMessage(error);\n\n          if (isObject(fieldForm.errors[error])) {\n            if (fieldForm.errors[error].errorPath) {\n              return;\n            }\n\n            if (fieldForm.errors[error].message) {\n              message = fieldForm.errors[error].message;\n            }\n          }\n\n          if (this.field.validation && this.field.validation.messages && this.field.validation.messages[error]) {\n            message = this.field.validation.messages[error];\n          }\n\n          if (this.field.validators && this.field.validators[error] && this.field.validators[error].message) {\n            message = this.field.validators[error].message;\n          }\n\n          if (this.field.asyncValidators && this.field.asyncValidators[error] && this.field.asyncValidators[error].message) {\n            message = this.field.asyncValidators[error].message;\n          }\n\n          if (typeof message === 'function') {\n            return message(fieldForm.errors[error], this.field);\n          }\n\n          return message;\n        }\n      }\n    }\n  }]);\n\n  return FormlyValidationMessage;\n}();\n\nFormlyValidationMessage.ɵfac = function FormlyValidationMessage_Factory(t) {\n  return new (t || FormlyValidationMessage)(ɵngcc0.ɵɵdirectiveInject(FormlyConfig));\n};\n\nFormlyValidationMessage.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: FormlyValidationMessage,\n  selectors: [[\"formly-validation-message\"]],\n  inputs: {\n    field: \"field\"\n  },\n  features: [ɵngcc0.ɵɵNgOnChangesFeature],\n  decls: 2,\n  vars: 3,\n  template: function FormlyValidationMessage_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵtext(0);\n      ɵngcc0.ɵɵpipe(1, \"async\");\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(1, 1, ctx.errorMessage$));\n    }\n  },\n  pipes: [ɵngcc2.AsyncPipe],\n  encapsulation: 2,\n  changeDetection: 0\n});\n/** @nocollapse */\n\nFormlyValidationMessage.ctorParameters = function () {\n  return [{\n    type: FormlyConfig\n  }];\n};\n\nFormlyValidationMessage.propDecorators = {\n  field: [{\n    type: Input\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormlyValidationMessage, [{\n    type: Component,\n    args: [{\n      selector: 'formly-validation-message',\n      template: \"{{ errorMessage$ | async }}\",\n      changeDetection: ChangeDetectionStrategy.OnPush\n    }]\n  }], function () {\n    return [{\n      type: FormlyConfig\n    }];\n  }, {\n    field: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar FormlyTemplateType = /*#__PURE__*/function (_FieldType5) {\n  _inherits(FormlyTemplateType, _FieldType5);\n\n  var _super5 = _createSuper(FormlyTemplateType);\n\n  /**\n   * @param {?} sanitizer\n   */\n  function FormlyTemplateType(sanitizer) {\n    var _this23;\n\n    _classCallCheck(this, FormlyTemplateType);\n\n    _this23 = _super5.call(this);\n    _this23.sanitizer = sanitizer;\n    _this23.innerHtml = {\n      content: null,\n      template: null\n    };\n    return _this23;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(FormlyTemplateType, [{\n    key: \"template\",\n    get: function get() {\n      if (this.field && this.field.template !== this.innerHtml.template) {\n        this.innerHtml = {\n          template: this.field.template,\n          content: this.to.safeHtml ? this.sanitizer.bypassSecurityTrustHtml(this.field.template) : this.field.template\n        };\n      }\n\n      return this.innerHtml.content;\n    }\n  }]);\n\n  return FormlyTemplateType;\n}(FieldType);\n\nFormlyTemplateType.ɵfac = function FormlyTemplateType_Factory(t) {\n  return new (t || FormlyTemplateType)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.DomSanitizer));\n};\n\nFormlyTemplateType.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: FormlyTemplateType,\n  selectors: [[\"formly-template\"]],\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n  decls: 1,\n  vars: 1,\n  consts: [[3, \"innerHtml\"]],\n  template: function FormlyTemplateType_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵelement(0, \"div\", 0);\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵproperty(\"innerHtml\", ctx.template, ɵngcc0.ɵɵsanitizeHtml);\n    }\n  },\n  encapsulation: 2\n});\n/** @nocollapse */\n\nFormlyTemplateType.ctorParameters = function () {\n  return [{\n    type: DomSanitizer\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormlyTemplateType, [{\n    type: Component,\n    args: [{\n      selector: 'formly-template',\n      template: \"<div [innerHtml]=\\\"template\\\"></div>\"\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc3.DomSanitizer\n    }];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} expression\n * @param {?} argNames\n * @return {?}\n */\n\n\nfunction evalStringExpression(expression, argNames) {\n  try {\n    if (expression.indexOf('this.field') !== -1) {\n      console.warn(\"NgxFormly: using 'this.field' in expressionProperties is deprecated since v5.1, use 'field' instead.\");\n    }\n\n    return (\n      /** @type {?} */\n      Function.apply(void 0, _toConsumableArray(argNames).concat([\"return \".concat(expression, \";\")]))\n    );\n  } catch (error) {\n    console.error(error);\n  }\n}\n/**\n * @param {?} expression\n * @param {?} thisArg\n * @param {?} argVal\n * @return {?}\n */\n\n\nfunction evalExpression(expression, thisArg, argVal) {\n  if (expression instanceof Function) {\n    return expression.apply(thisArg, argVal);\n  } else {\n    return expression ? true : false;\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@experimental\n */\n\n\nvar FieldExpressionExtension = /*#__PURE__*/function () {\n  function FieldExpressionExtension() {\n    _classCallCheck(this, FieldExpressionExtension);\n  }\n\n  _createClass(FieldExpressionExtension, [{\n    key: \"prePopulate\",\n    value:\n    /**\n     * @param {?} field\n     * @return {?}\n     */\n    function prePopulate(field) {\n      var _this24 = this;\n\n      if (field.parent || field.options._checkField) {\n        return;\n      }\n      /** @type {?} */\n\n\n      var checkLocked = false;\n\n      field.options._checkField =\n      /**\n      * @param {?} f\n      * @param {?} ignoreCache\n      * @return {?}\n      */\n      function (f, ignoreCache) {\n        if (!checkLocked) {\n          checkLocked = true;\n\n          _this24.checkField(f, ignoreCache);\n\n          checkLocked = false;\n        }\n      };\n    }\n    /**\n     * @param {?} field\n     * @return {?}\n     */\n\n  }, {\n    key: \"postPopulate\",\n    value: function postPopulate(field) {\n      var _this25 = this;\n\n      if (!field.parent || field._expressionProperties) {\n        return;\n      } // cache built expression\n\n\n      defineHiddenProp(field, '_expressionProperties', {});\n\n      if (field.expressionProperties) {\n        var _loop2 = function _loop2(key) {\n          /** @type {?} */\n          var expressionProperty = field.expressionProperties[key];\n\n          if (typeof expressionProperty === 'string' || isFunction(expressionProperty)) {\n            field._expressionProperties[key] = {\n              expression: _this25._evalExpression(key, expressionProperty, key === 'templateOptions.disabled' && field.parent.expressionProperties && field.parent.expressionProperties.hasOwnProperty('templateOptions.disabled') ?\n              /**\n              * @return {?}\n              */\n              function () {\n                return field.parent.templateOptions.disabled;\n              } : undefined)\n            };\n\n            if (key === 'templateOptions.disabled') {\n              Object.defineProperty(field._expressionProperties[key], 'expressionValue', {\n                get:\n                /**\n                * @return {?}\n                */\n                function get() {\n                  return field.templateOptions.disabled;\n                },\n                set:\n                /**\n                * @return {?}\n                */\n                function set() {},\n                enumerable: true,\n                configurable: true\n              });\n            }\n          } else if (expressionProperty instanceof Observable) {\n            /** @type {?} */\n            var subscribe =\n            /**\n            * @return {?}\n            */\n            function subscribe() {\n              return (\n                /** @type {?} */\n                expressionProperty.subscribe(\n                /**\n                * @param {?} v\n                * @return {?}\n                */\n                function (v) {\n                  _this25.setExprValue(field, key, v);\n\n                  if (field.options && field.options._markForCheck) {\n                    field.options._markForCheck(field);\n                  }\n                })\n              );\n            };\n            /** @type {?} */\n\n\n            var subscription = subscribe();\n            /** @type {?} */\n\n            var onInit = field.hooks.onInit;\n\n            field.hooks.onInit =\n            /**\n            * @return {?}\n            */\n            function () {\n              if (subscription === null) {\n                subscription = subscribe();\n              }\n\n              return onInit && onInit(field);\n            };\n            /** @type {?} */\n\n\n            var onDestroy = field.hooks.onDestroy;\n\n            field.hooks.onDestroy =\n            /**\n            * @return {?}\n            */\n            function () {\n              onDestroy && onDestroy(field);\n              subscription.unsubscribe();\n              subscription = null;\n            };\n          }\n        };\n\n        for (var key in field.expressionProperties) {\n          _loop2(key);\n        }\n      }\n\n      if (field.hideExpression) {\n        // delete hide value in order to force re-evaluate it in FormlyFormExpression.\n        delete field.hide;\n        field.hideExpression = this._evalExpression('hide', field.hideExpression,\n        /**\n        * @return {?}\n        */\n        function () {\n          /** @type {?} */\n          var root = field.parent;\n\n          while (root.parent && !root.hide) {\n            root = root.parent;\n          }\n\n          return root.hide;\n        });\n      } else {\n        wrapProperty(field, 'hide',\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref14) {\n          var currentValue = _ref14.currentValue,\n              firstChange = _ref14.firstChange;\n          field._hide = currentValue;\n\n          if (!firstChange || firstChange && currentValue === true) {\n            field.options._hiddenFieldsForCheck.push(field);\n          }\n        });\n      }\n    }\n    /**\n     * @private\n     * @param {?} prop\n     * @param {?} expression\n     * @param {?=} parentExpression\n     * @return {?}\n     */\n\n  }, {\n    key: \"_evalExpression\",\n    value: function _evalExpression(prop, _expression, parentExpression) {\n      return (\n        /**\n        * @param {...?} args\n        * @return {?}\n        */\n        function () {\n          try {\n            if (typeof _expression === 'string') {\n              _expression = evalStringExpression(_expression, ['model', 'formState', 'field']);\n            }\n\n            if (typeof _expression !== 'function') {\n              _expression =\n              /**\n              * @return {?}\n              */\n              function expression() {\n                return !!_expression;\n              };\n            }\n\n            return parentExpression && parentExpression() || _expression.apply(void 0, arguments);\n          } catch (error) {\n            error.message = \"[Formly Error] [Expression \\\"\".concat(prop, \"\\\"] \").concat(error.message);\n            throw error;\n          }\n        }\n      );\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?=} ignoreCache\n     * @return {?}\n     */\n\n  }, {\n    key: \"checkField\",\n    value: function checkField(field) {\n      var _this26 = this;\n\n      var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      /** @type {?} */\n      var fieldChanged = this._checkField(field, ignoreCache);\n\n      field.options._hiddenFieldsForCheck.sort(\n      /**\n      * @param {?} f\n      * @return {?}\n      */\n      function (f) {\n        return f.hide ? -1 : 1;\n      }).forEach(\n      /**\n      * @param {?} f\n      * @return {?}\n      */\n      function (f) {\n        return _this26.toggleFormControl(f, !!f.hide, !ignoreCache);\n      });\n\n      field.options._hiddenFieldsForCheck = [];\n\n      if (fieldChanged) {\n        this.checkField(field);\n\n        if (field.options && field.options._markForCheck) {\n          field.options._markForCheck(field);\n        }\n      }\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?=} ignoreCache\n     * @return {?}\n     */\n\n  }, {\n    key: \"_checkField\",\n    value: function _checkField(field) {\n      var _this27 = this;\n\n      var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      /** @type {?} */\n      var fieldChanged = false;\n      field.fieldGroup.forEach(\n      /**\n      * @param {?} f\n      * @return {?}\n      */\n      function (f) {\n        if (!f.options) {\n          return;\n        }\n\n        _this27.checkFieldExpressionChange(f, ignoreCache) && (fieldChanged = true);\n\n        if (_this27.checkFieldVisibilityChange(f, ignoreCache)) {\n          field.options._hiddenFieldsForCheck.push(f);\n\n          fieldChanged = true;\n        }\n\n        if (f.fieldGroup && f.fieldGroup.length > 0) {\n          _this27._checkField(f, ignoreCache) && (fieldChanged = true);\n        }\n      });\n      return fieldChanged;\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} ignoreCache\n     * @return {?}\n     */\n\n  }, {\n    key: \"checkFieldExpressionChange\",\n    value: function checkFieldExpressionChange(field, ignoreCache) {\n      if (!field || !field._expressionProperties) {\n        return false;\n      }\n      /** @type {?} */\n\n\n      var markForCheck = false;\n      /** @type {?} */\n\n      var expressionProperties = field._expressionProperties;\n\n      for (var key in expressionProperties) {\n        /** @type {?} */\n        var expressionValue = evalExpression(expressionProperties[key].expression, {\n          field: field\n        }, [field.model, field.options.formState, field, ignoreCache]);\n\n        if (key === 'templateOptions.disabled') {\n          expressionValue = !!expressionValue;\n        }\n\n        if (ignoreCache || expressionProperties[key].expressionValue !== expressionValue && (!(isObject(expressionValue) || isFunction(expressionValue)) || isFunction(expressionValue) && '' + expressionProperties[key].expressionValue !== '' + expressionValue || isObservable(expressionValue) || JSON.stringify(expressionValue) !== JSON.stringify(expressionProperties[key].expressionValue))) {\n          markForCheck = true;\n          expressionProperties[key].expressionValue = expressionValue;\n          this.setExprValue(field, key, expressionValue);\n        }\n      }\n\n      return markForCheck;\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} ignoreCache\n     * @return {?}\n     */\n\n  }, {\n    key: \"checkFieldVisibilityChange\",\n    value: function checkFieldVisibilityChange(field, ignoreCache) {\n      if (!field || isNullOrUndefined(field.hideExpression)) {\n        return false;\n      }\n      /** @type {?} */\n\n\n      var hideExpressionResult = !!evalExpression(field.hideExpression, {\n        field: field\n      }, [field.model, field.options.formState, field, ignoreCache]);\n      /** @type {?} */\n\n      var markForCheck = false;\n\n      if (hideExpressionResult !== field.hide || ignoreCache) {\n        markForCheck = true; // toggle hide\n\n        field.hide = hideExpressionResult;\n        field.templateOptions.hidden = hideExpressionResult;\n      }\n\n      return markForCheck;\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} value\n     * @return {?}\n     */\n\n  }, {\n    key: \"setDisabledState\",\n    value: function setDisabledState(field, value) {\n      var _this28 = this;\n\n      if (field.fieldGroup) {\n        field.fieldGroup.filter(\n        /**\n        * @param {?} f\n        * @return {?}\n        */\n        function (f) {\n          return !f.expressionProperties || !f.expressionProperties.hasOwnProperty('templateOptions.disabled');\n        }).forEach(\n        /**\n        * @param {?} f\n        * @return {?}\n        */\n        function (f) {\n          return _this28.setDisabledState(f, value);\n        });\n      }\n\n      if (field.key && field.templateOptions.disabled !== value) {\n        field.templateOptions.disabled = value;\n      }\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} hide\n     * @param {?} resetOnHide\n     * @return {?}\n     */\n\n  }, {\n    key: \"toggleFormControl\",\n    value: function toggleFormControl(field, hide, resetOnHide) {\n      var _this29 = this;\n\n      if (field.fieldGroup) {\n        field.fieldGroup.filter(\n        /**\n        * @param {?} f\n        * @return {?}\n        */\n        function (f) {\n          return !f.hideExpression;\n        }).forEach(\n        /**\n        * @param {?} f\n        * @return {?}\n        */\n        function (f) {\n          return _this29.toggleFormControl(f, hide, resetOnHide);\n        });\n      }\n\n      if (field.formControl && field.key) {\n        defineHiddenProp(field, '_hide', !!(hide || field.hide));\n        /** @type {?} */\n\n        var c = field.formControl;\n\n        if (c['_fields'] && c['_fields'].length > 1) {\n          updateValidity(c);\n        }\n\n        if (hide === true && (!c['_fields'] || c['_fields'].every(\n        /**\n        * @param {?} f\n        * @return {?}\n        */\n        function (f) {\n          return !!f._hide;\n        }))) {\n          unregisterControl(field, true);\n\n          if (resetOnHide && field.resetOnHide) {\n            field.formControl.reset({\n              value: undefined,\n              disabled: field.formControl.disabled\n            });\n\n            if (field.fieldGroup) {\n              assignFieldValue(field, undefined);\n\n              if (field.formControl instanceof FormArray) {\n                field.fieldGroup.length = 0;\n              }\n            }\n          }\n        } else if (hide === false) {\n          if (field.resetOnHide && field.parent && !isUndefined(field.defaultValue) && isUndefined(getFieldValue(field))) {\n            assignFieldValue(field, field.defaultValue);\n          }\n\n          registerControl(field, undefined, true);\n\n          if (field.resetOnHide && field.fieldArray && (field.fieldGroup || []).length !== (field.model || []).length) {\n            /** @type {?} */\n            field.options._buildForm(true);\n          }\n        }\n      }\n\n      if (field.options.fieldChanges) {\n        field.options.fieldChanges.next(\n        /** @type {?} */\n        {\n          field: field,\n          type: 'hidden',\n          value: hide\n        });\n      }\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} prop\n     * @param {?} value\n     * @return {?}\n     */\n\n  }, {\n    key: \"setExprValue\",\n    value: function setExprValue(field, prop, value) {\n      try {\n        /** @type {?} */\n        var target = field;\n        /** @type {?} */\n\n        var paths = prop.indexOf('[') === -1 ? prop.split('.') : prop.replace(/\\'|\\\"/g, '').split(/[[\\]]{1,2}/) // https://stackoverflow.com/a/20198206\n        .filter(\n        /**\n        * @param {?} v\n        * @return {?}\n        */\n        function (v) {\n          return v;\n        });\n        /** @type {?} */\n\n        var lastIndex = paths.length - 1;\n\n        for (var i = 0; i < lastIndex; i++) {\n          target = target[paths[i]];\n        }\n\n        target[paths[lastIndex]] = value;\n      } catch (error) {\n        error.message = \"[Formly Error] [Expression \\\"\".concat(prop, \"\\\"] \").concat(error.message);\n        throw error;\n      }\n\n      if (prop === 'templateOptions.disabled' && field.key) {\n        this.setDisabledState(field, value);\n      }\n\n      if (prop.indexOf('model.') === 0) {\n        /** @type {?} */\n        var path = prop.replace(/^model\\./, '');\n        /** @type {?} */\n\n        var control = field.key && prop === path ? field.formControl : field.parent.formControl.get(path);\n\n        if (control && !(isNullOrUndefined(control.value) && isNullOrUndefined(value)) && control.value !== value) {\n          control.patchValue(value);\n        }\n      }\n\n      this.emitExpressionChanges(field, prop, value);\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} property\n     * @param {?} value\n     * @return {?}\n     */\n\n  }, {\n    key: \"emitExpressionChanges\",\n    value: function emitExpressionChanges(field, property, value) {\n      if (!field.options.fieldChanges) {\n        return;\n      }\n\n      field.options.fieldChanges.next({\n        field: field,\n        type: 'expressionChanges',\n        property: property,\n        value: value\n      });\n    }\n  }]);\n\n  return FieldExpressionExtension;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@experimental\n */\n\n\nvar FieldValidationExtension = /*#__PURE__*/function () {\n  /**\n   * @param {?} formlyConfig\n   */\n  function FieldValidationExtension(formlyConfig) {\n    _classCallCheck(this, FieldValidationExtension);\n\n    this.formlyConfig = formlyConfig;\n  }\n  /**\n   * @param {?} field\n   * @return {?}\n   */\n\n\n  _createClass(FieldValidationExtension, [{\n    key: \"onPopulate\",\n    value: function onPopulate(field) {\n      this.initFieldValidation(field, 'validators');\n      this.initFieldValidation(field, 'asyncValidators');\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} type\n     * @return {?}\n     */\n\n  }, {\n    key: \"initFieldValidation\",\n    value: function initFieldValidation(field, type) {\n      var _this30 = this;\n\n      /** @type {?} */\n      var validators = [];\n\n      if (type === 'validators' && !(field.hasOwnProperty('fieldGroup') && !field.key)) {\n        validators.push(this.getPredefinedFieldValidation(field));\n      }\n\n      if (field[type]) {\n        for (var validatorName in field[type]) {\n          if (validatorName === 'validation' && !Array.isArray(field[type].validation)) {\n            field[type].validation = [field[type].validation];\n            console.warn(\"NgxFormly(\".concat(field.key, \"): passing a non array value to the 'validation' is deprecated, pass an array instead\"));\n          }\n\n          validatorName === 'validation' ? validators.push.apply(validators, _toConsumableArray(field[type].validation.map(\n          /**\n          * @param {?} v\n          * @return {?}\n          */\n          function (v) {\n            return _this30.wrapNgValidatorFn(field, v);\n          }))) : validators.push(this.wrapNgValidatorFn(field, field[type][validatorName], validatorName));\n        }\n      }\n\n      defineHiddenProp(field, '_' + type, validators);\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @return {?}\n     */\n\n  }, {\n    key: \"getPredefinedFieldValidation\",\n    value: function getPredefinedFieldValidation(field) {\n      /** @type {?} */\n      var VALIDATORS = [];\n      FORMLY_VALIDATORS.forEach(\n      /**\n      * @param {?} opt\n      * @return {?}\n      */\n      function (opt) {\n        return wrapProperty(field.templateOptions, opt,\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref15) {\n          var currentValue = _ref15.currentValue,\n              firstChange = _ref15.firstChange;\n          VALIDATORS = VALIDATORS.filter(\n          /**\n          * @param {?} o\n          * @return {?}\n          */\n          function (o) {\n            return o !== opt;\n          });\n\n          if (currentValue != null && currentValue !== false) {\n            VALIDATORS.push(opt);\n          }\n\n          if (!firstChange && field.formControl) {\n            updateValidity(field.formControl);\n          }\n        });\n      });\n      return (\n        /**\n        * @param {?} control\n        * @return {?}\n        */\n        function (control) {\n          if (VALIDATORS.length === 0) {\n            return null;\n          }\n\n          return Validators.compose(VALIDATORS.map(\n          /**\n          * @param {?} opt\n          * @return {?}\n          */\n          function (opt) {\n            return (\n              /**\n              * @return {?}\n              */\n              function () {\n                /** @type {?} */\n                var value = field.templateOptions[opt];\n\n                switch (opt) {\n                  case 'required':\n                    return Validators.required(control);\n\n                  case 'pattern':\n                    return Validators.pattern(value)(control);\n\n                  case 'minLength':\n                    return Validators.minLength(value)(control);\n\n                  case 'maxLength':\n                    return Validators.maxLength(value)(control);\n\n                  case 'min':\n                    return Validators.min(value)(control);\n\n                  case 'max':\n                    return Validators.max(value)(control);\n                }\n              }\n            );\n          }))(control);\n        }\n      );\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} validator\n     * @param {?=} validatorName\n     * @return {?}\n     */\n\n  }, {\n    key: \"wrapNgValidatorFn\",\n    value: function wrapNgValidatorFn(field, validator, validatorName) {\n      var _this31 = this;\n\n      /** @type {?} */\n      var validatorOption = null;\n\n      if (typeof validator === 'string') {\n        validatorOption = clone(this.formlyConfig.getValidator(validator));\n      }\n\n      if (typeof validator === 'object' && validator.name) {\n        validatorOption = clone(this.formlyConfig.getValidator(validator.name));\n\n        if (validator.options) {\n          validatorOption.options = validator.options;\n        }\n      }\n\n      if (typeof validator === 'object' && validator.expression) {\n        var expression = validator.expression,\n            options = __rest(validator, [\"expression\"]);\n\n        validatorOption = {\n          name: validatorName,\n          validation: expression,\n          options: Object.keys(options).length > 0 ? options : null\n        };\n      }\n\n      if (typeof validator === 'function') {\n        validatorOption = {\n          name: validatorName,\n          validation: validator\n        };\n      }\n\n      return (\n        /**\n        * @param {?} control\n        * @return {?}\n        */\n        function (control) {\n          /** @type {?} */\n          var errors = validatorOption.validation(control, field, validatorOption.options);\n\n          if (isPromise(errors)) {\n            return errors.then(\n            /**\n            * @param {?} v\n            * @return {?}\n            */\n            function (v) {\n              return _this31.handleAsyncResult(field, validatorName ? !!v : v, validatorOption);\n            });\n          }\n\n          if (isObservable(errors)) {\n            return errors.pipe(map(\n            /**\n            * @param {?} v\n            * @return {?}\n            */\n            function (v) {\n              return _this31.handleAsyncResult(field, validatorName ? !!v : v, validatorOption);\n            }));\n          }\n\n          return _this31.handleResult(field, validatorName ? !!errors : errors, validatorOption);\n        }\n      );\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} errors\n     * @param {?} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"handleAsyncResult\",\n    value: function handleAsyncResult(field, errors, options) {\n      // workaround for https://github.com/angular/angular/issues/13200\n      if (field.options && field.options._markForCheck) {\n        field.options._markForCheck(field);\n      }\n\n      return this.handleResult(field, errors, options);\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} errors\n     * @param {?} __2\n     * @return {?}\n     */\n\n  }, {\n    key: \"handleResult\",\n    value: function handleResult(field, errors, _ref16) {\n      var name = _ref16.name,\n          options = _ref16.options;\n\n      if (typeof errors === 'boolean') {\n        errors = errors ? null : _defineProperty({}, name, options ? options : true);\n      }\n      /** @type {?} */\n\n\n      var ctrl = field.formControl;\n      ctrl['_childrenErrors'] && ctrl['_childrenErrors'][name] && ctrl['_childrenErrors'][name]();\n\n      if (isObject(errors)) {\n        Object.keys(errors).forEach(\n        /**\n        * @param {?} name\n        * @return {?}\n        */\n        function (name) {\n          /** @type {?} */\n          var errorPath = errors[name].errorPath ? errors[name].errorPath : (options || {}).errorPath;\n          /** @type {?} */\n\n          var childCtrl = errorPath ? field.formControl.get(errorPath) : null;\n\n          if (childCtrl) {\n            var _a = errors[name],\n                opts = __rest(_a, [\"errorPath\"]);\n\n            childCtrl.setErrors(Object.assign({}, childCtrl.errors || {}, _defineProperty({}, name, opts)));\n            !ctrl['_childrenErrors'] && defineHiddenProp(ctrl, '_childrenErrors', {});\n\n            ctrl['_childrenErrors'][name] =\n            /**\n            * @return {?}\n            */\n            function () {\n              var _a = childCtrl.errors || {},\n                  _b = name,\n                  toDelete = _a[_b],\n                  childErrors = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n              childCtrl.setErrors(Object.keys(childErrors).length === 0 ? null : childErrors);\n            };\n          }\n        });\n      }\n\n      return errors;\n    }\n  }]);\n\n  return FieldValidationExtension;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@experimental\n */\n\n\nvar FieldFormExtension = /*#__PURE__*/function () {\n  /**\n   * @param {?} config\n   */\n  function FieldFormExtension(config) {\n    _classCallCheck(this, FieldFormExtension);\n\n    this.config = config;\n  }\n  /**\n   * @param {?} field\n   * @return {?}\n   */\n\n\n  _createClass(FieldFormExtension, [{\n    key: \"onPopulate\",\n    value: function onPopulate(field) {\n      if (!field.parent) {\n        return;\n      }\n\n      if (field.fieldGroup && !field.key) {\n        defineHiddenProp(field, 'formControl', field.parent.formControl);\n      } else {\n        this.addFormControl(field);\n      }\n    }\n    /**\n     * @param {?} field\n     * @return {?}\n     */\n\n  }, {\n    key: \"postPopulate\",\n    value: function postPopulate(field) {\n      if (field.parent) {\n        return;\n      }\n\n      this.setValidators(field);\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @return {?}\n     */\n\n  }, {\n    key: \"addFormControl\",\n    value: function addFormControl(field) {\n      /** @type {?} */\n      var control = findControl(field);\n\n      if (!control) {\n        /** @type {?} */\n        var controlOptions = {\n          updateOn: field.modelOptions.updateOn\n        };\n        /** @type {?} */\n\n        var value = field.key ? getFieldValue(field) : field.defaultValue;\n        /** @type {?} */\n\n        var ref = this.config ? this.config.resolveFieldTypeRef(field) : null;\n\n        if (ref && ref.componentType && ref.componentType['createControl']) {\n          /** @type {?} */\n          var component = ref.componentType;\n          console.warn(\"NgxFormly: '\".concat(component.name, \"::createControl' is deprecated since v5.0, use 'prePopulate' hook instead.\"));\n          control = component['createControl'](value, field);\n        } else if (field.fieldGroup) {\n          // TODO: move to postPopulate\n          control = new FormGroup({}, controlOptions);\n        } else {\n          control = new FormControl(value, controlOptions);\n        }\n      }\n\n      registerControl(field, control);\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?=} disabled\n     * @return {?}\n     */\n\n  }, {\n    key: \"setValidators\",\n    value: function setValidators(field) {\n      var _this32 = this;\n\n      var disabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      /** @type {?} */\n      var markForCheck = false;\n\n      if (disabled === false && field.key && field.templateOptions && field.templateOptions.disabled) {\n        disabled = true;\n      }\n\n      (field.fieldGroup || []).forEach(\n      /**\n      * @param {?} f\n      * @return {?}\n      */\n      function (f) {\n        return _this32.setValidators(f, disabled) && (markForCheck = true);\n      });\n\n      if (field.key || !field.parent || !field.key && !field.fieldGroup) {\n        var c = field.formControl;\n        field.templateOptions = field.templateOptions || {};\n\n        if (field.key && c && c instanceof FormControl) {\n          if (disabled && c.enabled) {\n            c.disable({\n              emitEvent: false,\n              onlySelf: true\n            });\n            markForCheck = true;\n          }\n\n          if (!disabled && c.disabled) {\n            c.enable({\n              emitEvent: false,\n              onlySelf: true\n            });\n            markForCheck = true;\n          }\n        }\n\n        if (c && (null === c.validator || null === c.asyncValidator)) {\n          c.setValidators(\n          /**\n          * @return {?}\n          */\n          function () {\n            /** @type {?} */\n            var v = Validators.compose(_this32.mergeValidators(field, '_validators'));\n            return v ? v(c) : null;\n          });\n          c.setAsyncValidators(\n          /**\n          * @return {?}\n          */\n          function () {\n            /** @type {?} */\n            var v = Validators.composeAsync(_this32.mergeValidators(field, '_asyncValidators'));\n            return v ? v(c) : of(null);\n          });\n          markForCheck = true;\n        }\n\n        if (markForCheck) {\n          updateValidity(c, true);\n        }\n      }\n\n      return markForCheck;\n    }\n    /**\n     * @private\n     * @template T\n     * @param {?} field\n     * @param {?} type\n     * @return {?}\n     */\n\n  }, {\n    key: \"mergeValidators\",\n    value: function mergeValidators(field, type) {\n      var _this33 = this;\n\n      /** @type {?} */\n      var validators = [];\n      /** @type {?} */\n\n      var c = field.formControl;\n\n      if (c && c['_fields'] && c['_fields'].length > 1) {\n        c['_fields'].filter(\n        /**\n        * @param {?} f\n        * @return {?}\n        */\n        function (f) {\n          return !f._hide;\n        }).forEach(\n        /**\n        * @param {?} f\n        * @return {?}\n        */\n        function (f) {\n          return validators.push.apply(validators, _toConsumableArray(f[type]));\n        });\n      } else if (field[type]) {\n        validators.push.apply(validators, _toConsumableArray(field[type]));\n      }\n\n      if (field.fieldGroup) {\n        field.fieldGroup.filter(\n        /**\n        * @param {?} f\n        * @return {?}\n        */\n        function (f) {\n          return !f.key && f.fieldGroup;\n        }).forEach(\n        /**\n        * @param {?} f\n        * @return {?}\n        */\n        function (f) {\n          return validators.push.apply(validators, _toConsumableArray(_this33.mergeValidators(f, type)));\n        });\n      }\n\n      return validators;\n    }\n  }]);\n\n  return FieldFormExtension;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@experimental\n */\n\n\nvar CoreExtension = /*#__PURE__*/function () {\n  /**\n   * @param {?} formlyConfig\n   */\n  function CoreExtension(formlyConfig) {\n    _classCallCheck(this, CoreExtension);\n\n    this.formlyConfig = formlyConfig;\n    this.formId = 0;\n  }\n  /**\n   * @param {?} field\n   * @return {?}\n   */\n\n\n  _createClass(CoreExtension, [{\n    key: \"prePopulate\",\n    value: function prePopulate(field) {\n      this.getFieldComponentInstance(field).prePopulate();\n\n      if (field.parent) {\n        return;\n      }\n      /** @type {?} */\n\n\n      var fieldTransforms = field.options && field.options.fieldTransform || this.formlyConfig.extras.fieldTransform;\n      (Array.isArray(fieldTransforms) ? fieldTransforms : [fieldTransforms]).forEach(\n      /**\n      * @param {?} fieldTransform\n      * @return {?}\n      */\n      function (fieldTransform) {\n        if (fieldTransform) {\n          console.warn(\"NgxFormly: fieldTransform is deprecated since v5.0, use custom extension instead.\");\n          /** @type {?} */\n\n          var fieldGroup = fieldTransform(field.fieldGroup, field.model,\n          /** @type {?} */\n          field.formControl, field.options);\n\n          if (!fieldGroup) {\n            throw new Error('fieldTransform must return an array of fields');\n          }\n        }\n      });\n    }\n    /**\n     * @param {?} field\n     * @return {?}\n     */\n\n  }, {\n    key: \"onPopulate\",\n    value: function onPopulate(field) {\n      var _this34 = this;\n\n      this.initFieldOptions(field);\n      this.getFieldComponentInstance(field).onPopulate();\n\n      if (field.fieldGroup) {\n        field.fieldGroup.forEach(\n        /**\n        * @param {?} f\n        * @param {?} index\n        * @return {?}\n        */\n        function (f, index) {\n          Object.defineProperty(f, 'parent', {\n            get:\n            /**\n            * @return {?}\n            */\n            function get() {\n              return field;\n            },\n            configurable: true\n          });\n          Object.defineProperty(f, 'index', {\n            get:\n            /**\n            * @return {?}\n            */\n            function get() {\n              return index;\n            },\n            configurable: true\n          });\n          _this34.formId++;\n        });\n      }\n    }\n    /**\n     * @param {?} field\n     * @return {?}\n     */\n\n  }, {\n    key: \"postPopulate\",\n    value: function postPopulate(field) {\n      this.getFieldComponentInstance(field).postPopulate();\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @return {?}\n     */\n\n  }, {\n    key: \"initFieldOptions\",\n    value: function initFieldOptions(field) {\n      /** @type {?} */\n      var root =\n      /** @type {?} */\n      field.parent;\n\n      if (!root) {\n        return;\n      }\n\n      Object.defineProperty(field, 'form', {\n        get:\n        /**\n        * @return {?}\n        */\n        function get() {\n          return root.formControl;\n        },\n        configurable: true\n      });\n      Object.defineProperty(field, 'options', {\n        get:\n        /**\n        * @return {?}\n        */\n        function get() {\n          return root.options;\n        },\n        configurable: true\n      });\n      Object.defineProperty(field, 'model', {\n        get:\n        /**\n        * @return {?}\n        */\n        function get() {\n          return field.key && field.fieldGroup ? getFieldValue(field) : root.model;\n        },\n        configurable: true\n      });\n      reverseDeepMerge(field, {\n        id: getFieldId(\"formly_\".concat(this.formId), field, field['index']),\n        hooks: {},\n        modelOptions: {},\n        validation: {\n          messages: {}\n        },\n        templateOptions: !field.type || !field.key ? {} : {\n          label: '',\n          placeholder: '',\n          focus: false,\n          disabled: false\n        }\n      });\n\n      if (this.formlyConfig.extras.resetFieldOnHide && field.resetOnHide !== false) {\n        field.resetOnHide = true;\n      }\n\n      if (field.lifecycle) {\n        console.warn(\"NgxFormly: 'lifecycle' is deprecated since v5.0, use 'hooks' instead.\");\n      }\n\n      if (field.type !== 'formly-template' && (field.template || field.expressionProperties && field.expressionProperties.template)) {\n        if (field.type) {\n          console.warn(\"NgxFormly: passing 'type' property is not allowed when 'template' is set.\");\n        }\n\n        field.type = 'formly-template';\n      }\n\n      if (!field.type && field.fieldGroup) {\n        field.type = 'formly-group';\n      }\n\n      if (field.type) {\n        this.formlyConfig.getMergedField(field);\n      }\n\n      if (field.parent) {\n        /** @type {?} */\n        var setDefaultValue = !isUndefined(field.key) && !isUndefined(field.defaultValue) && isUndefined(getFieldValue(field)) && (!field.resetOnHide || !(field.hide || field.hideExpression));\n\n        if (setDefaultValue && field.resetOnHide) {\n          /** @type {?} */\n          var parent = field.parent;\n\n          while (parent && !parent.hideExpression && !parent.hide) {\n            parent = parent.parent;\n          }\n\n          setDefaultValue = !parent || !(parent.hideExpression || parent.hide);\n        }\n\n        if (setDefaultValue) {\n          assignFieldValue(field, field.defaultValue);\n        }\n      }\n\n      this.initFieldWrappers(field);\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @return {?}\n     */\n\n  }, {\n    key: \"initFieldWrappers\",\n    value: function initFieldWrappers(field) {\n      field.wrappers = field.wrappers || [];\n      /** @type {?} */\n\n      var fieldTemplateManipulators = Object.assign({\n        preWrapper: [],\n        postWrapper: []\n      }, field.templateOptions.templateManipulators || {});\n      field.wrappers = [].concat(_toConsumableArray(this.formlyConfig.templateManipulators.preWrapper.map(\n      /**\n      * @param {?} m\n      * @return {?}\n      */\n      function (m) {\n        return m(field);\n      })), _toConsumableArray(fieldTemplateManipulators.preWrapper.map(\n      /**\n      * @param {?} m\n      * @return {?}\n      */\n      function (m) {\n        return m(field);\n      })), _toConsumableArray(field.wrappers), _toConsumableArray(this.formlyConfig.templateManipulators.postWrapper.map(\n      /**\n      * @param {?} m\n      * @return {?}\n      */\n      function (m) {\n        return m(field);\n      })), _toConsumableArray(fieldTemplateManipulators.postWrapper.map(\n      /**\n      * @param {?} m\n      * @return {?}\n      */\n      function (m) {\n        return m(field);\n      }))).filter(\n      /**\n      * @param {?} el\n      * @param {?} i\n      * @param {?} a\n      * @return {?}\n      */\n      function (el, i, a) {\n        return el && i === a.indexOf(el);\n      });\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @return {?}\n     */\n\n  }, {\n    key: \"getFieldComponentInstance\",\n    value: function getFieldComponentInstance(field) {\n      /** @type {?} */\n      var componentRef = this.formlyConfig.resolveFieldTypeRef(field);\n      /** @type {?} */\n\n      var instance = componentRef ?\n      /** @type {?} */\n      componentRef.instance : {};\n      return {\n        prePopulate:\n        /**\n        * @return {?}\n        */\n        function prePopulate() {\n          return instance.prePopulate && instance.prePopulate(field);\n        },\n        onPopulate:\n        /**\n        * @return {?}\n        */\n        function onPopulate() {\n          return instance.onPopulate && instance.onPopulate(field);\n        },\n        postPopulate:\n        /**\n        * @return {?}\n        */\n        function postPopulate() {\n          return instance.postPopulate && instance.postPopulate(field);\n        }\n      };\n    }\n  }]);\n\n  return CoreExtension;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} formlyConfig\n * @return {?}\n */\n\n\nfunction defaultFormlyConfig(formlyConfig) {\n  return {\n    types: [{\n      name: 'formly-group',\n      component: FormlyGroup\n    }, {\n      name: 'formly-template',\n      component: FormlyTemplateType\n    }],\n    extensions: [{\n      name: 'core',\n      extension: new CoreExtension(formlyConfig)\n    }, {\n      name: 'field-validation',\n      extension: new FieldValidationExtension(formlyConfig)\n    }, {\n      name: 'field-form',\n      extension: new FieldFormExtension(formlyConfig)\n    }, {\n      name: 'field-expression',\n      extension: new FieldExpressionExtension()\n    }]\n  };\n}\n\nvar FormlyModule = /*#__PURE__*/function () {\n  /**\n   * @param {?} configService\n   * @param {?=} configs\n   */\n  function FormlyModule(configService) {\n    var configs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    _classCallCheck(this, FormlyModule);\n\n    if (!configs) {\n      return;\n    }\n\n    configs.forEach(\n    /**\n    * @param {?} config\n    * @return {?}\n    */\n    function (config) {\n      return configService.addConfig(config);\n    });\n  }\n  /**\n   * @param {?=} config\n   * @return {?}\n   */\n\n\n  _createClass(FormlyModule, null, [{\n    key: \"forRoot\",\n    value: function forRoot() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return {\n        ngModule: FormlyModule,\n        providers: [{\n          provide: FORMLY_CONFIG,\n          multi: true,\n          useFactory: defaultFormlyConfig,\n          deps: [FormlyConfig]\n        }, {\n          provide: FORMLY_CONFIG,\n          useValue: config,\n          multi: true\n        }, {\n          provide: ANALYZE_FOR_ENTRY_COMPONENTS,\n          useValue: config,\n          multi: true\n        }, FormlyConfig, FormlyFormBuilder]\n      };\n    }\n    /**\n     * @param {?=} config\n     * @return {?}\n     */\n\n  }, {\n    key: \"forChild\",\n    value: function forChild() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return {\n        ngModule: FormlyModule,\n        providers: [{\n          provide: FORMLY_CONFIG,\n          multi: true,\n          useFactory: defaultFormlyConfig,\n          deps: [FormlyConfig]\n        }, {\n          provide: FORMLY_CONFIG,\n          useValue: config,\n          multi: true\n        }, {\n          provide: ANALYZE_FOR_ENTRY_COMPONENTS,\n          useValue: config,\n          multi: true\n        }, FormlyFormBuilder]\n      };\n    }\n  }]);\n\n  return FormlyModule;\n}();\n\nFormlyModule.ɵfac = function FormlyModule_Factory(t) {\n  return new (t || FormlyModule)(ɵngcc0.ɵɵinject(FormlyConfig), ɵngcc0.ɵɵinject(FORMLY_CONFIG, 8));\n};\n\nFormlyModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: FormlyModule\n});\nFormlyModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n  imports: [[CommonModule]]\n});\n/** @nocollapse */\n\nFormlyModule.ctorParameters = function () {\n  return [{\n    type: FormlyConfig\n  }, {\n    type: Array,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [FORMLY_CONFIG]\n    }]\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormlyModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [FormlyForm, FormlyField, FormlyAttributes, FormlyGroup, FormlyValidationMessage, FormlyTemplateType,\n      /** @type {?} */\n      FieldArrayType],\n      entryComponents: [FormlyGroup, FormlyTemplateType],\n      exports: [FormlyForm, FormlyField, FormlyAttributes, FormlyGroup, FormlyValidationMessage],\n      imports: [CommonModule]\n    }]\n  }], function () {\n    return [{\n      type: FormlyConfig\n    }, {\n      type: Array,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [FORMLY_CONFIG]\n      }]\n    }];\n  }, null);\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FormlyModule, {\n    declarations: function declarations() {\n      return [FormlyForm, FormlyField, FormlyAttributes, FormlyGroup, FormlyValidationMessage, FormlyTemplateType, FieldArrayType];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [FormlyForm, FormlyField, FormlyAttributes, FormlyGroup, FormlyValidationMessage];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { FormlyForm, FormlyField, FormlyAttributes, FORMLY_CONFIG, FormlyConfig, FormlyFormBuilder, FieldType, Field, FieldArrayType, FieldWrapper, FormlyModule, defineHiddenProp as ɵdefineHiddenProp, reverseDeepMerge as ɵreverseDeepMerge, getFieldValue as ɵgetFieldValue, clone as ɵclone, wrapProperty as ɵwrapProperty, defaultFormlyConfig as ɵa, CoreExtension as ɵe, FieldExpressionExtension as ɵh, FieldFormExtension as ɵg, FieldValidationExtension as ɵf, FormlyTemplateType as ɵd, FormlyGroup as ɵb, FormlyValidationMessage as ɵc }; //# sourceMappingURL=ngx-formly-core.js.map","map":null,"metadata":{},"sourceType":"module"}