{"ast":null,"code":"import { EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, ChangeDetectorRef, Renderer2, ElementRef, NgZone, Output, Input, Directive, HostListener, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nconst _traverseChildren =\n/**\n* @param {?} tree\n* @param {?} callback\n* @param {?=} parent\n* @return {?}\n*/\n(tree, callback, parent = null) => {\n  for (let i = 0; i < tree.length; i++) {\n    /** @type {?} */\n    const item = tree[i];\n\n    if (typeof item === 'undefined') {\n      continue;\n    }\n    /** @type {?} */\n\n\n    const callbackResult = callback(item, parent);\n\n    if (callbackResult) {\n      break;\n    }\n\n    if (item.children) {\n      _traverseChildren(item.children, callback, item);\n    }\n  }\n};\n/** @type {?} */\n\n\nconst _insertAfter =\n/**\n* @param {?} newNode\n* @param {?} referenceNode\n* @return {?}\n*/\n(newNode, referenceNode) => {\n  referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n};\n/** @type {?} */\n\n\nconst _replace =\n/**\n* @param {?} newNode\n* @param {?} referenceNode\n* @return {?}\n*/\n(newNode, referenceNode) => {\n  referenceNode.parentNode.replaceChild(newNode, referenceNode);\n};\n/** @type {?} */\n\n\nconst _replaceTargetWithElements =\n/**\n* @param {?} target\n* @param {?} elements\n* @return {?}\n*/\n(target, elements) => {\n  /** @type {?} */\n  let i = elements.length;\n\n  if (target.parentNode) {\n    while (i--) {\n      target.parentNode.insertBefore(elements[i], target);\n    } /// remove the target.\n\n\n    target.parentNode.removeChild(target);\n  }\n};\n/** @type {?} */\n\n\nconst _getParents =\n/**\n* @param {?} el\n* @param {?=} parentSelector\n* @return {?}\n*/\n(el, parentSelector = document.body) => {\n  /** @type {?} */\n  const parents = [];\n  /** @type {?} */\n\n  let parentNode = el.parentNode;\n\n  while (parentNode !== parentSelector) {\n    /** @type {?} */\n    const o = parentNode;\n\n    if (!parentNode) {\n      break;\n    }\n\n    if (parentNode.tagName === parentSelector.tagName) {\n      parents.push(o);\n    }\n\n    parentNode = o.parentNode;\n  }\n\n  parents.push(parentSelector); // Push that parentSelector you wanted to stop at\n\n  return parents;\n};\n/** @type {?} */\n\n\nconst _closest =\n/**\n* @param {?} el\n* @param {?} selector\n* @return {?}\n*/\n(el, selector) => {\n  /** @type {?} */\n  let matchesFn; // find vendor prefix\n\n  ['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'].some(\n  /**\n  * @param {?} fn\n  * @return {?}\n  */\n  function (fn) {\n    if (typeof document.body[fn] === 'function') {\n      matchesFn = fn;\n      return true;\n    }\n\n    return false;\n  });\n  /** @type {?} */\n\n  let parent; // traverse parents\n\n  while (el) {\n    parent = el.parentElement;\n\n    if (parent === null) {\n      break;\n    }\n    /** @type {?} */\n\n\n    const matches = parent[matchesFn](selector);\n\n    if (parent && matches) {\n      return parent;\n    }\n\n    el = parent;\n  }\n\n  return null;\n};\n/** @type {?} */\n\n\nconst _offset =\n/**\n* @param {?} elem\n* @return {?}\n*/\nelem => {\n  /** @type {?} */\n  let box = {\n    top: 0,\n    left: 0\n  }; // BlackBerry 5, iOS 3 (original iPhone)\n\n  if (typeof elem.getBoundingClientRect !== undefined) {\n    box = elem.getBoundingClientRect();\n  }\n\n  return {\n    top: box.top + (window.pageYOffset || elem.scrollTop) - (elem.clientTop || 0),\n    left: box.left + (window.pageXOffset || elem.scrollLeft) - (elem.clientLeft || 0)\n  };\n};\n/** @type {?} */\n\n\nconst _findObjectInTree =\n/**\n* @param {?} array\n* @param {?} id\n* @return {?}\n*/\n(array, id) => {\n  /** @type {?} */\n  let result = null;\n\n  _traverseChildren(array,\n  /**\n  * @param {?} item\n  * @return {?}\n  */\n  item => {\n    if (item['$$id'] === Number.parseInt(id)) {\n      result = item;\n      return true;\n    }\n  });\n\n  return result;\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst REGISTER_HANDLE = 'NESTABLE_DRAG_HANDLE_REGISTER';\n/** @type {?} */\n\nconst DRAG_START = 'NESTABLE_DRAG_HANDLE_START';\n/** @type {?} */\n\nconst EXPAND_COLLAPSE = 'NESTABLE_EXPAND_COLLAPSE_EVENT';\n/** @type {?} */\n\nconst defaultSettings =\n/** @type {?} */\n{\n  listNodeName: 'ul',\n  itemNodeName: 'li',\n  rootClass: 'dd',\n  listClass: 'dd-list',\n  itemClass: 'dd-item',\n  dragClass: 'dd-dragel',\n  handleClass: 'dd-handle',\n  collapsedClass: 'dd-collapsed',\n  placeClass: 'dd-placeholder',\n  group: 0,\n  // TODO\n  maxDepth: 5,\n  threshold: 20,\n  fixedDepth: false,\n  // fixed item's depth\n  exportCollapsed: true,\n  // TODO\n  disableDrag: false\n};\n/** @type {?} */\n\nconst mouse = {\n  moving: 0,\n  offsetX: 0,\n  offsetY: 0,\n  startX: 0,\n  startY: 0,\n  lastX: 0,\n  lastY: 0,\n  nowX: 0,\n  nowY: 0,\n  distX: 0,\n  distY: 0,\n  dirAx: 0,\n  dirX: 0,\n  dirY: 0,\n  lastDirX: 0,\n  lastDirY: 0,\n  distAxX: 0,\n  distAxY: 0\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nconst PX = 'px';\n\nconst ɵ0 =\n/**\n* @return {?}\n*/\nfunction () {\n  /** @type {?} */\n  const el = document.createElement('div');\n  /** @type {?} */\n\n  const docEl = document.documentElement;\n\n  if (!('pointerEvents' in el.style)) {\n    return false;\n  }\n\n  el.style.pointerEvents = 'auto';\n  el.style.pointerEvents = 'x';\n  docEl.appendChild(el);\n  /** @type {?} */\n\n  const supports = window.getComputedStyle && window.getComputedStyle(el, '').pointerEvents === 'auto';\n  docEl.removeChild(el);\n  return !!supports;\n};\n/** @type {?} */\n\n\nconst hasPointerEvents = ɵ0();\n\nclass NestableComponent {\n  /**\n   * @param {?} ref\n   * @param {?} renderer\n   * @param {?} el\n   * @param {?} zone\n   */\n  constructor(ref, renderer, el, zone) {\n    this.ref = ref;\n    this.renderer = renderer;\n    this.el = el;\n    this.zone = zone;\n    this.listChange = new EventEmitter();\n    this.drop = new EventEmitter();\n    this.drag = new EventEmitter();\n    this.disclosure = new EventEmitter();\n    this.options = defaultSettings;\n    this.disableDrag = false;\n    this.dragRootEl = null;\n    this.dragEl = null;\n    this.dragModel = null;\n    this.moving = false;\n    /**\n     * Dragged element contains children, and those children contain other children and so on...\n     * This property gives you the number of generations contained within the dragging item.\n     */\n\n    this.dragDepth = 0;\n    /**\n     * The depth of dragging item relative to element root (ngx-nestable)\n     */\n\n    this.relativeDepth = 0;\n    this.hasNewRoot = false;\n    this.pointEl = null;\n    this.items = [];\n    this._componentActive = false;\n    this._mouse = Object.assign({}, mouse);\n    this._list = [];\n    this._itemId = 0;\n    this._registerHandleDirective = false;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get list() {\n    return this._list;\n  }\n  /**\n   * @param {?} list\n   * @return {?}\n   */\n\n\n  set list(list) {\n    this._list = list;\n\n    this._generateItemIds();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnInit() {\n    // set/extend default options\n    this._componentActive = true;\n    /** @type {?} */\n\n    const optionKeys = Object.keys(defaultSettings);\n\n    for (const key of optionKeys) {\n      if (typeof this.options[key] === 'undefined') {\n        this.options[key] = defaultSettings[key];\n      }\n    }\n\n    this._generateItemIds();\n\n    this._generateItemExpanded();\n\n    this._createHandleListener();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnDestroy() {}\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  _generateItemIds() {\n    _traverseChildren(this._list,\n    /**\n    * @param {?} item\n    * @return {?}\n    */\n    item => {\n      item['$$id'] = this._itemId++;\n    });\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  _generateItemExpanded() {\n    _traverseChildren(this._list,\n    /**\n    * @param {?} item\n    * @return {?}\n    */\n    item => {\n      if (typeof item.expanded === 'undefined') {\n        item['$$expanded'] = true;\n      } else {\n        item['$$expanded'] = item.expanded;\n      }\n    });\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  _createHandleListener() {\n    this.renderer.listen(this.el.nativeElement, REGISTER_HANDLE,\n    /**\n    * @return {?}\n    */\n    () => {\n      this._registerHandleDirective = true;\n    });\n    this.renderer.listen(this.el.nativeElement, DRAG_START,\n    /**\n    * @param {?} data\n    * @return {?}\n    */\n    data => {\n      this.dragStart(data.detail.event, data.detail.param.item, data.detail.param.parentList);\n    });\n    this.renderer.listen(this.el.nativeElement, EXPAND_COLLAPSE,\n    /**\n    * @param {?} data\n    * @return {?}\n    */\n    data => {\n      this.disclosure.emit({\n        item: data.detail.item,\n        expanded: data.detail.item['$$expanded']\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {?} event\n   * @param {?} dragItem\n   * @return {?}\n   */\n\n\n  _createDragClone(event, dragItem) {\n    this._mouseStart(event, dragItem);\n\n    if (!this._registerHandleDirective) {\n      this._mouse.offsetY = dragItem.nextElementSibling ? dragItem.nextElementSibling.clientHeight / 2 : dragItem.clientHeight / 2;\n    } // create drag clone\n\n\n    this.dragEl = document.createElement(this.options.listNodeName);\n    document.body.appendChild(this.dragEl);\n    this.renderer.addClass(this.dragEl, this.options.dragClass); // add drag clone to body and set css\n\n    this.renderer.setStyle(this.dragEl, 'left', event.pageX - this._mouse.offsetX + PX);\n    this.renderer.setStyle(this.dragEl, 'top', event.pageY - this._mouse.offsetY + PX);\n    this.renderer.setStyle(this.dragEl, 'position', 'absolute');\n    this.renderer.setStyle(this.dragEl, 'z-index', 9999);\n    this.renderer.setStyle(this.dragEl, 'pointer-events', 'none');\n  }\n  /**\n   * @private\n   * @param {?} event\n   * @param {?} dragItem\n   * @return {?}\n   */\n\n\n  _createPlaceholder(event, dragItem) {\n    this._placeholder = document.createElement('div');\n\n    this._placeholder.classList.add(this.options.placeClass);\n\n    _insertAfter(this._placeholder, dragItem);\n\n    dragItem.parentNode.removeChild(dragItem);\n    this.dragEl.appendChild(dragItem);\n    this.dragRootEl = dragItem;\n  }\n  /**\n   * Sets depth proerties (relative and drag)\n   * @private\n   * @return {?}\n   */\n\n\n  _calculateDepth() {\n    // total depth of dragging item\n\n    /** @type {?} */\n    let depth;\n    /** @type {?} */\n\n    const items = this.dragEl.querySelectorAll(this.options.itemNodeName);\n\n    for (let i = 0; i < items.length; i++) {\n      depth = _getParents(items[i], this.dragEl).length;\n\n      if (depth > this.dragDepth) {\n        this.dragDepth = depth;\n      }\n    } // depth relative to root\n\n\n    this.relativeDepth = _getParents(this._placeholder, this.el.nativeElement.querySelector(this.options.listNodeName)).length;\n  }\n  /**\n   * @private\n   * @param {?} event\n   * @param {?} dragItem\n   * @return {?}\n   */\n\n\n  _mouseStart(event, dragItem) {\n    this._mouse.offsetX = event.pageX - _offset(dragItem).left;\n    this._mouse.offsetY = event.pageY - _offset(dragItem).top;\n    this._mouse.startX = this._mouse.lastX = event.pageX;\n    this._mouse.startY = this._mouse.lastY = event.pageY;\n  }\n  /**\n   * @private\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  _mouseUpdate(event) {\n    // mouse position last events\n    this._mouse.lastX = this._mouse.nowX;\n    this._mouse.lastY = this._mouse.nowY; // mouse position this events\n\n    this._mouse.nowX = event.pageX;\n    this._mouse.nowY = event.pageY; // distance mouse moved between events\n\n    this._mouse.distX = this._mouse.nowX - this._mouse.lastX;\n    this._mouse.distY = this._mouse.nowY - this._mouse.lastY; // direction mouse was moving\n\n    this._mouse.lastDirX = this._mouse.dirX;\n    this._mouse.lastDirY = this._mouse.dirY; // direction mouse is now moving (on both axis)\n\n    this._mouse.dirX = this._mouse.distX === 0 ? 0 : this._mouse.distX > 0 ? 1 : -1;\n    this._mouse.dirY = this._mouse.distY === 0 ? 0 : this._mouse.distY > 0 ? 1 : -1;\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  _showMasks() {\n    /** @type {?} */\n    const masks = this.el.nativeElement.getElementsByClassName('nestable-item-mask');\n\n    for (let i = 0; i < masks.length; i++) {\n      masks[i].style.display = 'block';\n    }\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  _hideMasks() {\n    /** @type {?} */\n    const masks = this.el.nativeElement.getElementsByClassName('nestable-item-mask');\n\n    for (let i = 0; i < masks.length; i++) {\n      masks[i].style.display = 'none';\n    }\n  }\n  /**\n   * calc mouse traverse distance on axis\n   * @private\n   * @param {?} m - mouse\n   * @return {?}\n   */\n\n\n  _calcMouseDistance(m) {\n    m.distAxX += Math.abs(m.distX);\n\n    if (m.dirX !== 0 && m.dirX !== m.lastDirX) {\n      m.distAxX = 0;\n    }\n\n    m.distAxY += Math.abs(m.distY);\n\n    if (m.dirY !== 0 && m.dirY !== m.lastDirY) {\n      m.distAxY = 0;\n    }\n  }\n  /**\n   * @private\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  _move(event) {\n    /** @type {?} */\n    let depth;\n    /** @type {?} */\n\n    let list;\n    /** @type {?} */\n\n    const dragRect = this.dragEl.getBoundingClientRect();\n    this.renderer.setStyle(this.dragEl, 'left', event.pageX - this._mouse.offsetX + PX);\n    this.renderer.setStyle(this.dragEl, 'top', event.pageY - this._mouse.offsetY + PX);\n\n    this._mouseUpdate(event); // axis mouse is now moving on\n\n    /** @type {?} */\n\n\n    const newAx = Math.abs(this._mouse.distX) > Math.abs(this._mouse.distY) ? 1 : 0; // do nothing on first move\n\n    if (!this._mouse.moving) {\n      this._mouse.dirAx = newAx;\n      this._mouse.moving = 1;\n      return;\n    } // calc distance moved on this axis (and direction)\n\n\n    if (this._mouse.dirAx !== newAx) {\n      this._mouse.distAxX = 0;\n      this._mouse.distAxY = 0;\n    } else {\n      this._calcMouseDistance(this._mouse);\n    }\n\n    this._mouse.dirAx = newAx; // find list item under cursor\n\n    if (!hasPointerEvents) {\n      this.dragEl.style.visibility = 'hidden';\n    }\n    /** @type {?} */\n\n\n    const pointEl = document.elementFromPoint(event.pageX - document.body.scrollLeft, event.pageY - (window.pageYOffset || document.documentElement.scrollTop));\n\n    if (!hasPointerEvents) {\n      this.dragEl.style.visibility = 'visible';\n    }\n\n    if (pointEl && (pointEl.classList.contains('nestable-item-mask') || pointEl.classList.contains(this.options.placeClass))) {\n      this.pointEl = pointEl.parentElement.parentElement;\n    } else {\n      return;\n    }\n    /**\n     * move horizontal\n     */\n\n\n    if (!this.options.fixedDepth && this._mouse.dirAx && this._mouse.distAxX >= this.options.threshold) {\n      // reset move distance on x-axis for new phase\n      this._mouse.distAxX = 0;\n      /** @type {?} */\n\n      const previous = this._placeholder.previousElementSibling; // increase horizontal level if previous sibling exists, is not collapsed, and can have children\n\n      if (this._mouse.distX > 0 && previous) {\n        list = previous.querySelectorAll(this.options.listNodeName);\n        list = list[list.length - 1]; // check if depth limit has reached\n\n        depth = _getParents(this._placeholder, this.el.nativeElement.querySelector(this.options.listNodeName)).length;\n\n        if (depth + this.dragDepth <= this.options.maxDepth) {\n          // create new sub-level if one doesn't exist\n          if (!list) {\n            list = document.createElement(this.options.listNodeName);\n            list.style.paddingLeft = this.options.threshold + PX;\n            list.appendChild(this._placeholder);\n            previous.appendChild(list); // this.setParent(previous);\n          } else {\n            // else append to next level up\n            list = previous.querySelector(`:scope > ${this.options.listNodeName}`);\n            list.appendChild(this._placeholder);\n          }\n        }\n      } // decrease horizontal level\n\n\n      if (this._mouse.distX < 0) {\n        // we can't decrease a level if an item preceeds the current one\n\n        /** @type {?} */\n        const next = document.querySelector(`.${this.options.placeClass} + ${this.options.itemNodeName}`);\n        /** @type {?} */\n\n        const parentElement = this._placeholder.parentElement;\n\n        if (!next && parentElement) {\n          /** @type {?} */\n          const closestItem = _closest(this._placeholder, this.options.itemNodeName);\n\n          if (closestItem) {\n            parentElement.removeChild(this._placeholder);\n\n            _insertAfter(this._placeholder, closestItem);\n          }\n        }\n      }\n    }\n\n    if (!pointEl.classList.contains('nestable-item-mask')) {\n      return;\n    } // find root list of item under cursor\n\n    /** @type {?} */\n\n\n    const pointElRoot = _closest(this.pointEl, `.${this.options.rootClass}`);\n    /** @type {?} */\n\n\n    const isNewRoot = pointElRoot ? this.dragRootEl.dataset['nestable-id'] !== pointElRoot.dataset['nestable-id'] : false;\n    /**\n     * move vertical\n     */\n\n    if (!this._mouse.dirAx || isNewRoot) {\n      // check if groups match if dragging over new root\n      if (isNewRoot && this.options.group !== pointElRoot.dataset['nestable-group']) {\n        return;\n      } // check depth limit\n\n\n      depth = this.dragDepth - 1 + _getParents(this.pointEl, this.el.nativeElement.querySelector(this.options.listNodeName)).length;\n\n      if (depth > this.options.maxDepth) {\n        return;\n      }\n      /** @type {?} */\n\n\n      const before = event.pageY < _offset(this.pointEl).top + this.pointEl.clientHeight / 2;\n      /** @type {?} */\n\n      const placeholderParent = this._placeholder.parentNode; // get point element depth\n\n      /** @type {?} */\n\n      let pointRelativeDepth;\n      pointRelativeDepth = _getParents(this.pointEl, this.el.nativeElement.querySelector(this.options.listNodeName)).length;\n\n      if (this.options.fixedDepth) {\n        if (pointRelativeDepth === this.relativeDepth - 1) {\n          /** @type {?} */\n          const childList = this.pointEl.querySelector(this.options.listNodeName);\n\n          if (!childList.children.length) {\n            childList.appendChild(this._placeholder);\n          }\n        } else if (pointRelativeDepth === this.relativeDepth) {\n          if (before) {\n            this.pointEl.parentElement.insertBefore(this._placeholder, this.pointEl);\n          } else {\n            _insertAfter(this._placeholder, this.pointEl);\n          }\n\n          if (Array.prototype.indexOf.call(this.pointEl.parentElement.children, this.pointEl) === this.pointEl.parentElement.children.length - 1) {\n            _insertAfter(this._placeholder, this.pointEl);\n          }\n        }\n      } else if (before) {\n        this.pointEl.parentElement.insertBefore(this._placeholder, this.pointEl);\n      } else {\n        _insertAfter(this._placeholder, this.pointEl);\n      }\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  reset() {\n    /** @type {?} */\n    const keys = Object.keys(this._mouse);\n\n    for (const key of keys) {\n      this._mouse[key] = 0;\n    }\n\n    this._itemId = 0;\n    this.moving = false;\n    this.dragEl = null;\n    this.dragRootEl = null;\n    this.dragDepth = 0;\n    this.relativeDepth = 0;\n    this.hasNewRoot = false;\n    this.pointEl = null;\n  }\n  /**\n   * @param {?} event\n   * @param {?} item\n   * @param {?} parentList\n   * @return {?}\n   */\n\n\n  dragStartFromItem(event, item, parentList) {\n    if (!this._registerHandleDirective) {\n      this.dragStart(event, item, parentList);\n    }\n  }\n  /**\n   * @private\n   * @param {?} event\n   * @param {?} item\n   * @param {?} parentList\n   * @return {?}\n   */\n\n\n  dragStart(event, item, parentList) {\n    this._oldListLength = this.list.length;\n\n    if (!this.options.disableDrag) {\n      event.stopPropagation();\n      event.preventDefault();\n\n      if (event.originalEvent) {\n        event = event.originalEvent;\n      } // allow only first mouse button\n\n\n      if (event.type.indexOf('mouse') === 0) {\n        if (event.button !== 0) {\n          return;\n        }\n      } else {\n        if (event.touches.length !== 1) {\n          return;\n        }\n      }\n\n      this.ref.detach();\n      this._dragIndex = parentList.indexOf(item);\n      this.dragModel = parentList.splice(parentList.indexOf(item), 1)[0];\n      /** @type {?} */\n\n      const dragItem = _closest(event.target, this.options.itemNodeName);\n\n      if (dragItem === null) {\n        return;\n      }\n\n      this._parentDragId = Number.parseInt(dragItem.parentElement.parentElement.id);\n      /** @type {?} */\n\n      const dragRect = dragItem.getBoundingClientRect();\n\n      this._showMasks();\n\n      this._createDragClone(event, dragItem);\n\n      this.renderer.setStyle(this.dragEl, 'width', dragRect.width + PX);\n\n      this._createPlaceholder(event, dragItem);\n\n      this.renderer.setStyle(this._placeholder, 'height', dragRect.height + PX);\n\n      this._calculateDepth();\n\n      this.drag.emit({\n        originalEvent: event,\n        item\n      });\n      this._cancelMouseup = this.renderer.listen(document, 'mouseup', this.dragStop.bind(this));\n      this._cancelMousemove = this.renderer.listen(document, 'mousemove', this.dragMove.bind(this));\n    }\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  dragStop(event) {\n    this._cancelMouseup();\n\n    this._cancelMousemove();\n\n    this._hideMasks();\n\n    if (this.dragEl) {\n      /** @type {?} */\n      const draggedId = Number.parseInt(this.dragEl.firstElementChild.id);\n      /** @type {?} */\n\n      let placeholderContainer = _closest(this._placeholder, this.options.itemNodeName);\n      /** @type {?} */\n\n\n      let changedElementPosition = this._dragIndex !== Array.prototype.indexOf.call(this._placeholder.parentElement.children, this._placeholder);\n      /** @type {?} */\n\n      const index = Array.prototype.indexOf.call(this._placeholder.parentElement.children, this._placeholder);\n\n      if (this._dragIndex === index && this._oldListLength === this.list.length) {\n        changedElementPosition = true;\n      } // placeholder in root\n\n\n      if (placeholderContainer === null) {\n        this.list.splice(Array.prototype.indexOf.call(this._placeholder.parentElement.children, this._placeholder), 0, Object.assign({}, this.dragModel));\n      } else {\n        // palceholder nested\n        placeholderContainer = _findObjectInTree(this.list, Number.parseInt(placeholderContainer.id));\n\n        if (!placeholderContainer.children) {\n          placeholderContainer.children = [];\n          placeholderContainer.children.push(Object.assign({}, this.dragModel));\n        } else {\n          placeholderContainer.children.splice(Array.prototype.indexOf.call(this._placeholder.parentElement.children, this._placeholder), 0, Object.assign({}, this.dragModel));\n        }\n\n        if (index === this._dragIndex) {\n          changedElementPosition = false;\n        }\n\n        if (!changedElementPosition) {\n          changedElementPosition = placeholderContainer['$$id'] !== this._parentDragId;\n        }\n      }\n\n      this._placeholder.parentElement.removeChild(this._placeholder);\n\n      this.dragEl.parentNode.removeChild(this.dragEl);\n      this.dragEl.remove();\n      this.reset();\n      this.listChange.emit(this.list);\n      this.drop.emit({\n        originalEvent: event,\n        destination: placeholderContainer,\n        item: this.dragModel,\n        changedElementPosition\n      });\n      this.ref.reattach();\n    }\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  dragMove(event) {\n    if (this.dragEl) {\n      event.preventDefault();\n\n      if (event.originalEvent) {\n        event = event.originalEvent;\n      }\n\n      this._move(event.type.indexOf('mouse') === 0 ? event : event.touches[0]);\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  expandAll() {\n    _traverseChildren(this._list,\n    /**\n    * @param {?} item\n    * @return {?}\n    */\n    item => {\n      item['$$expanded'] = true;\n    });\n\n    this.ref.markForCheck();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  collapseAll() {\n    _traverseChildren(this._list,\n    /**\n    * @param {?} item\n    * @return {?}\n    */\n    item => {\n      item['$$expanded'] = false;\n    });\n\n    this.ref.markForCheck();\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  NestableComponent.prototype.listChange;\n  /** @type {?} */\n\n  NestableComponent.prototype.drop;\n  /** @type {?} */\n\n  NestableComponent.prototype.drag;\n  /** @type {?} */\n\n  NestableComponent.prototype.disclosure;\n  /** @type {?} */\n\n  NestableComponent.prototype.template;\n  /** @type {?} */\n\n  NestableComponent.prototype.options;\n  /** @type {?} */\n\n  NestableComponent.prototype.disableDrag;\n  /** @type {?} */\n\n  NestableComponent.prototype.dragRootEl;\n  /** @type {?} */\n\n  NestableComponent.prototype.dragEl;\n  /** @type {?} */\n\n  NestableComponent.prototype.dragModel;\n  /** @type {?} */\n\n  NestableComponent.prototype.moving;\n  /**\n   * Dragged element contains children, and those children contain other children and so on...\n   * This property gives you the number of generations contained within the dragging item.\n   * @type {?}\n   */\n\n  NestableComponent.prototype.dragDepth;\n  /**\n   * The depth of dragging item relative to element root (ngx-nestable)\n   * @type {?}\n   */\n\n  NestableComponent.prototype.relativeDepth;\n  /** @type {?} */\n\n  NestableComponent.prototype.hasNewRoot;\n  /** @type {?} */\n\n  NestableComponent.prototype.pointEl;\n  /** @type {?} */\n\n  NestableComponent.prototype.items;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NestableComponent.prototype._componentActive;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NestableComponent.prototype._mouse;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NestableComponent.prototype._list;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NestableComponent.prototype._cancelMousemove;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NestableComponent.prototype._cancelMouseup;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NestableComponent.prototype._placeholder;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NestableComponent.prototype._itemId;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NestableComponent.prototype._registerHandleDirective;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NestableComponent.prototype._dragIndex;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NestableComponent.prototype._parentDragId;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NestableComponent.prototype._oldListLength;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NestableComponent.prototype.ref;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NestableComponent.prototype.renderer;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NestableComponent.prototype.el;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NestableComponent.prototype.zone;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass NestableDragHandleDirective {\n  /**\n   * @param {?} _el\n   */\n  constructor(_el) {\n    this._el = _el;\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  onMouseDown(event) {\n    /** @type {?} */\n    const detail = {\n      param: this.ngxNestableDragHandle,\n      event: event\n    };\n\n    this._el.nativeElement.dispatchEvent(new CustomEvent(DRAG_START, {\n      bubbles: true,\n      detail: detail\n    }));\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnInit() {\n    this._el.nativeElement.dispatchEvent(new CustomEvent(REGISTER_HANDLE, {\n      bubbles: true,\n      detail: this.ngxNestableDragHandle\n    }));\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  NestableDragHandleDirective.prototype.ngxNestableDragHandle;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NestableDragHandleDirective.prototype._el;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass NestableExpandCollapseDirective {\n  /**\n   * @param {?} _el\n   */\n  constructor(_el) {\n    this._el = _el;\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  onMouseDown(event) {\n    event.stopPropagation();\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  onClick(event) {\n    this.ngxNestableExpandCollapse.item['$$expanded'] = !this.ngxNestableExpandCollapse.item['$$expanded'];\n\n    this._el.nativeElement.dispatchEvent(new CustomEvent(EXPAND_COLLAPSE, {\n      bubbles: true,\n      detail: this.ngxNestableExpandCollapse\n    }));\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  NestableExpandCollapseDirective.prototype.ngxNestableExpandCollapse;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  NestableExpandCollapseDirective.prototype._el;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass NestableModule {}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nexport { NestableComponent, NestableModule, NestableDragHandleDirective as ɵa, NestableExpandCollapseDirective as ɵb }; //# sourceMappingURL=ngx-nestable.js.map","map":null,"metadata":{},"sourceType":"module"}